<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>日损录</title>
  
  <subtitle>Feilishu&#39;s Note</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.feilishu.top/"/>
  <updated>2018-01-04T12:45:07.210Z</updated>
  <id>http://www.feilishu.top/</id>
  
  <author>
    <name>Feilishu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pandas学习笔记2：汇总和计算描述性统计</title>
    <link href="http://www.feilishu.top/2018/01/04/ch5.3-summarizing/"/>
    <id>http://www.feilishu.top/2018/01/04/ch5.3-summarizing/</id>
    <published>2018-01-04T11:15:55.000Z</published>
    <updated>2018-01-04T12:45:07.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇总和计算描述性统计"><a href="#汇总和计算描述性统计" class="headerlink" title="汇总和计算描述性统计"></a>汇总和计算描述性统计</h1><p>pandas包含一系列汇总和统计函数。多数函数属于归纳或者汇总统计的范畴，这些函数从Series中计算出一个单值（如sum和mean函数），或从DataFrame的每行（列）抽取出一个Series对象。与Numpy中相对应的函数不一样的是，pandas的函数内建处理缺失值的能力。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame([[<span class="number">1.4</span>, np.nan], [<span class="number">7.1</span>, <span class="number">-4.5</span>],[np.nan, np.nan], [<span class="number">0.75</span>, <span class="number">-1.3</span>]],index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>],columns=[<span class="string">'one'</span>, <span class="string">'two'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure><a id="more"></a><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.40</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>7.10</td><br>      <td>-4.5</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>0.75</td><br>      <td>-1.3</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sum()   <span class="comment">#按列统计每一行的和</span></span><br></pre></td></tr></table></figure><pre><code>one    9.25two   -5.80dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sum(axis=<span class="string">'columns'</span>) <span class="comment">#指定轴为列，则计算每行各列的和</span></span><br></pre></td></tr></table></figure><pre><code>a    1.40b    2.60c    0.00d   -0.55dtype: float64</code></pre><p>缺失值缺省情况下被排除于计算过程中。使用skipna参数修改这种行为。计算平均数的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.mean(axis=<span class="string">'columns'</span>)</span><br></pre></td></tr></table></figure><pre><code>a    1.400b    1.300c      NaNd   -0.275dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.mean(axis=<span class="string">'columns'</span>, skipna=<span class="keyword">False</span>)  <span class="comment">#只要包含Nan，则整行的平均值都是Nan。</span></span><br></pre></td></tr></table></figure><pre><code>a      NaNb    1.300c      NaNd   -0.275dtype: float64</code></pre><p>另外一些函数，如idxmax和idxmin函数，返回最大值或最小值对应的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.idxmax()</span><br></pre></td></tr></table></figure><pre><code>one    btwo    ddtype: object</code></pre><p>还有一种是累积函数，如cumsum。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.cumsum()</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.40</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>8.50</td><br>      <td>-4.5</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>9.25</td><br>      <td>-5.8</td><br>    </tr><br>  </tbody><br></table><br></div><p>还有一种函数既非归纳性函数也非累加性函数。如describe函数，它计算出一些统计数据的汇总性描述数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>count</th><br>      <td>3.000000</td><br>      <td>2.000000</td><br>    </tr><br>    <tr><br>      <th>mean</th><br>      <td>3.083333</td><br>      <td>-2.900000</td><br>    </tr><br>    <tr><br>      <th>std</th><br>      <td>3.493685</td><br>      <td>2.262742</td><br>    </tr><br>    <tr><br>      <th>min</th><br>      <td>0.750000</td><br>      <td>-4.500000</td><br>    </tr><br>    <tr><br>      <th>25%</th><br>      <td>1.075000</td><br>      <td>-3.700000</td><br>    </tr><br>    <tr><br>      <th>50%</th><br>      <td>1.400000</td><br>      <td>-2.900000</td><br>    </tr><br>    <tr><br>      <th>75%</th><br>      <td>4.250000</td><br>      <td>-2.100000</td><br>    </tr><br>    <tr><br>      <th>max</th><br>      <td>7.100000</td><br>      <td>-1.300000</td><br>    </tr><br>  </tbody><br></table><br></div><p>对于非数值数据，describe函数给出替代性的描述信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] * <span class="number">4</span>)</span><br><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>0     a1     a2     b3     c4     a5     a6     b7     c8     a9     a10    b11    c12    a13    a14    b15    cdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.describe() <span class="comment">#给出总数、不重复的数的数量、第一个值、重复最多的数</span></span><br></pre></td></tr></table></figure><pre><code>count     16unique     3top        afreq       8dtype: object</code></pre><p>描述性和汇总统计函数表</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>个数（不包含缺失值）</td></tr><tr><td>describe</td><td>汇总统计数值集合</td></tr><tr><td>min, max</td><td>最小、最大值</td></tr><tr><td>argmin, argmax</td><td>最小值、最大值所在的索引位置（整数）</td></tr><tr><td>idxmin, idxmax</td><td>最小值、最大值所在的索引标签</td></tr><tr><td>quantile</td><td>分位数</td></tr><tr><td>sum</td><td>和</td></tr><tr><td>mean</td><td>平均值</td></tr><tr><td>median</td><td>中位数</td></tr><tr><td>mad</td><td>与绝对值之间的平均绝对偏差</td></tr><tr><td>prod</td><td>阶乘</td></tr><tr><td>var</td><td>样本方差</td></tr><tr><td>std</td><td>样本标准差</td></tr><tr><td>skew</td><td>样本偏度</td></tr><tr><td>kurt</td><td>样本峰度</td></tr><tr><td>cumsum</td><td>累加和</td></tr><tr><td>cummin, cummax</td><td>累加最小值、累加最大值</td></tr><tr><td>cumprod</td><td>累加乘积</td></tr><tr><td>diff</td><td>计算算数差（时间序列比较有用）</td></tr><tr><td>pct_change</td><td>计算百分比变化</td></tr></tbody></table><h2 id="相关性和协方差"><a href="#相关性和协方差" class="headerlink" title="相关性和协方差"></a>相关性和协方差</h2><p>某些统计函数如相关性和协方差的函数是对成对参数进行计算。我们考虑一下，如果想要从Yahoo中获取股票价格和成交量的DataFrame，这需要安装另外的pandas-datareader包。如果还没有安装，可以使用<code>conda install pandas-datareader</code>安装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> web</span><br><span class="line">all_data = &#123;ticker: web.get_data_yahoo(ticker) <span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">'AAPL'</span>, <span class="string">'IBM'</span>, <span class="string">'MSFT'</span>, <span class="string">'GOOG'</span>]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">price = pd.DataFrame(&#123;ticker: data[<span class="string">'Adj Close'</span>] <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br><span class="line">volume = pd.DataFrame(&#123;ticker: data[<span class="string">'Volume'</span>] <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">returns = price.pct_change()</span><br><span class="line">returns.tail()   <span class="comment">#Yahoo已经被Verizon收购了，竟然还能取得数据，太神奇了！！！</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>GOOG</th><br>      <th>IBM</th><br>      <th>MSFT</th><br>    </tr><br>    <tr><br>      <th>Date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2017-12-22</th><br>      <td>0.000000</td><br>      <td>-0.003300</td><br>      <td>0.006601</td><br>      <td>0.000117</td><br>    </tr><br>    <tr><br>      <th>2017-12-26</th><br>      <td>-0.025370</td><br>      <td>-0.003188</td><br>      <td>0.002164</td><br>      <td>-0.001286</td><br>    </tr><br>    <tr><br>      <th>2017-12-27</th><br>      <td>0.000176</td><br>      <td>-0.006974</td><br>      <td>0.001963</td><br>      <td>0.003630</td><br>    </tr><br>    <tr><br>      <th>2017-12-28</th><br>      <td>0.002814</td><br>      <td>-0.001172</td><br>      <td>0.005943</td><br>      <td>0.000117</td><br>    </tr><br>    <tr><br>      <th>2017-12-29</th><br>      <td>-0.010814</td><br>      <td>-0.001660</td><br>      <td>-0.004025</td><br>      <td>-0.002100</td><br>    </tr><br>  </tbody><br></table><br></div><p>corr函数计算两个序列之间的相关系数。cov计算协方差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returns[<span class="string">'MSFT'</span>].corr(returns[<span class="string">'IBM'</span>])</span><br></pre></td></tr></table></figure><pre><code>0.46607663413008699</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returns[<span class="string">'MSFT'</span>].cov(returns[<span class="string">'IBM'</span>])</span><br></pre></td></tr></table></figure><pre><code>7.7153494329051242e-05</code></pre><p>因为MSFT是一个合法的python属性，所以也可以用属性访问的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returns.MSFT.corr(returns.IBM)</span><br></pre></td></tr></table></figure><pre><code>0.46607663413008699</code></pre><p>DataFrame的corr和cov函数可以计算两两之间的相关系统和协方差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returns.corr()</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>GOOG</th><br>      <th>IBM</th><br>      <th>MSFT</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>AAPL</th><br>      <td>1.000000</td><br>      <td>0.416158</td><br>      <td>0.355443</td><br>      <td>0.396363</td><br>    </tr><br>    <tr><br>      <th>GOOG</th><br>      <td>0.416158</td><br>      <td>1.000000</td><br>      <td>0.379598</td><br>      <td>0.480037</td><br>    </tr><br>    <tr><br>      <th>IBM</th><br>      <td>0.355443</td><br>      <td>0.379598</td><br>      <td>1.000000</td><br>      <td>0.466077</td><br>    </tr><br>    <tr><br>      <th>MSFT</th><br>      <td>0.396363</td><br>      <td>0.480037</td><br>      <td>0.466077</td><br>      <td>1.000000</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returns.cov()</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>GOOG</th><br>      <th>IBM</th><br>      <th>MSFT</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>AAPL</th><br>      <td>0.000254</td><br>      <td>0.000100</td><br>      <td>0.000067</td><br>      <td>0.000089</td><br>    </tr><br>    <tr><br>      <th>GOOG</th><br>      <td>0.000100</td><br>      <td>0.000228</td><br>      <td>0.000068</td><br>      <td>0.000102</td><br>    </tr><br>    <tr><br>      <th>IBM</th><br>      <td>0.000067</td><br>      <td>0.000068</td><br>      <td>0.000139</td><br>      <td>0.000077</td><br>    </tr><br>    <tr><br>      <th>MSFT</th><br>      <td>0.000089</td><br>      <td>0.000102</td><br>      <td>0.000077</td><br>      <td>0.000197</td><br>    </tr><br>  </tbody><br></table><br></div><p>使用corrwith函数，DataFrame的行或列可以与其他DataFrame或Series计算配对的相关性。<br>传入一个Series对象，则返回一个每列与之配对计算相关系数的Series对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returns.corrwith(returns.IBM)</span><br></pre></td></tr></table></figure><pre><code>AAPL    0.355443GOOG    0.379598IBM     1.000000MSFT    0.466077dtype: float64</code></pre><p>传入一个DataFrame对象，计算列名匹配的相关系数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returns.corrwith(volume)</span><br></pre></td></tr></table></figure><pre><code>AAPL   -0.068543GOOG   -0.013207IBM    -0.158880MSFT   -0.085835dtype: float64</code></pre><p><strong>可以使用<code>axis=&#39;columns&#39;</code>参数按行计算。</strong></p><h2 id="唯一值、值计数和成员关系。"><a href="#唯一值、值计数和成员关系。" class="headerlink" title="唯一值、值计数和成员关系。"></a>唯一值、值计数和成员关系。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>])</span><br><span class="line">uniques = obj.unique()  <span class="comment">#重复的元素保留一个</span></span><br><span class="line">uniques</span><br></pre></td></tr></table></figure><pre><code>array([&apos;c&apos;, &apos;a&apos;, &apos;d&apos;, &apos;b&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.value_counts()  <span class="comment">#计算每个值出现次数</span></span><br></pre></td></tr></table></figure><pre><code>a    3c    3b    2d    1dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.value_counts(obj.values, sort=<span class="keyword">False</span>)  <span class="comment">#value_counts作为pandas顶层函数提供，可应用于任何数组或序列</span></span><br></pre></td></tr></table></figure><pre><code>c    3d    1a    3b    2dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = obj.isin([<span class="string">'b'</span>, <span class="string">'c'</span>])  <span class="comment">#测试元素是否是参数的成员</span></span><br><span class="line">mask</span><br></pre></td></tr></table></figure><pre><code>0     True1    False2    False3    False4    False5     True6     True7     True8     Truedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[mask]  <span class="comment">#布尔数组过滤掉不是成员的元素</span></span><br></pre></td></tr></table></figure><pre><code>0    c5    b6    b7    c8    cdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">to_match = pd.Series([<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>])</span><br><span class="line">unique_vals = pd.Series([<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br><span class="line">pd.Index(unique_vals).get_indexer(to_match)  <span class="comment">#get_indexer函数返回每个元素在参数序列中匹配的索引位置</span></span><br></pre></td></tr></table></figure><pre><code>array([0, 2, 1, 1, 0, 2], dtype=int32)</code></pre><p>有时，我们需要对DataFrame的每列绘制直方图，不同的列之间存在相关关系。我们需要整体汇总所有的数据在每列中出现的次数，这时我们可以使用DataFrame的apply函数，其参数传入pandas.value_counts。举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'Qu1'</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                     <span class="string">'Qu2'</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                     <span class="string">'Qu3'</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">data</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Qu1</th><br>      <th>Qu2</th><br>      <th>Qu3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>3</td><br>      <td>3</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>4</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>3</td><br>      <td>2</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>4</td><br>      <td>3</td><br>      <td>4</td><br>    </tr><br>  </tbody><br></table><br></div><p>对每一列进行数据计数，结果的每一行是全部数据中的不重复值。若某一列对应的行标签所列出的数据不存在，该列对应的位置的数据则填充为0。<br>apply函数是按列对数据进行计数的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = data.apply(pd.value_counts).fillna(<span class="number">0</span>)  </span><br><span class="line">result</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Qu1</th><br>      <th>Qu2</th><br>      <th>Qu3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1</th><br>      <td>1.0</td><br>      <td>1.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.0</td><br>      <td>2.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2.0</td><br>      <td>2.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>2.0</td><br>      <td>0.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>    </tr><br>  </tbody><br></table><br></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇总和计算描述性统计&quot;&gt;&lt;a href=&quot;#汇总和计算描述性统计&quot; class=&quot;headerlink&quot; title=&quot;汇总和计算描述性统计&quot;&gt;&lt;/a&gt;汇总和计算描述性统计&lt;/h1&gt;&lt;p&gt;pandas包含一系列汇总和统计函数。多数函数属于归纳或者汇总统计的范畴，这些函数从Series中计算出一个单值（如sum和mean函数），或从DataFrame的每行（列）抽取出一个Series对象。与Numpy中相对应的函数不一样的是，pandas的函数内建处理缺失值的能力。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df = pd.DataFrame([[&lt;span class=&quot;number&quot;&gt;1.4&lt;/span&gt;, np.nan], [&lt;span class=&quot;number&quot;&gt;7.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-4.5&lt;/span&gt;],[np.nan, np.nan], [&lt;span class=&quot;number&quot;&gt;0.75&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1.3&lt;/span&gt;]],index=[&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;],columns=[&lt;span class=&quot;string&quot;&gt;&#39;one&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;two&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Pandas" scheme="http://www.feilishu.top/categories/IT/Language/Python/Pandas/"/>
    
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
      <category term="Pandas" scheme="http://www.feilishu.top/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>pandas学习笔记1：核心函数。</title>
    <link href="http://www.feilishu.top/2017/12/29/ch5.2-essential-func/"/>
    <id>http://www.feilishu.top/2017/12/29/ch5.2-essential-func/</id>
    <published>2017-12-29T11:15:55.000Z</published>
    <updated>2017-12-29T14:40:55.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、重建索引（Reindex）"><a href="#一、重建索引（Reindex）" class="headerlink" title="一、重建索引（Reindex）"></a>一、重建索引（Reindex）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, <span class="number">-5.3</span>, <span class="number">3.6</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>d    4.5b    7.2a   -5.3c    3.6dtype: float64</code></pre><a id="more"></a><p>对Series对象应用reindex函数后，将按参数指定的新索引进行重建数据，索引对应的数据如果本来不存在，那么会引进缺失值（NaN）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj2 = obj.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">obj2</span><br></pre></td></tr></table></figure><pre><code>a   -5.3b    7.2c    3.6d    4.5e    NaNdtype: float64</code></pre><p>与时间序列（Time Series）的有序数据类似，Series可以在重建索引时，method选项可以指定中间数据填充的模式。举例，method选项指定为ffill，会向前填充中间原不存在的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj3 = pd.Series([<span class="string">'blue'</span>, <span class="string">'purple'</span>, <span class="string">'yellow'</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line">obj3</span><br></pre></td></tr></table></figure><pre><code>0      blue2    purple4    yellowdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj3.reindex(range(<span class="number">6</span>), method=<span class="string">'ffill'</span>)  <span class="comment">#重建索引后，原索引标签中间原先没有的标签对应的数据则会根据前面的数据往前填充。</span></span><br></pre></td></tr></table></figure><pre><code>0      blue1      blue2    purple3    purple4    yellow5    yellowdtype: object</code></pre><p>对DataFrame来说，reindex函数可以调整行或列或者两者。若只传入一个序列，则只重建行索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)),index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>],columns=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'California'</span>])</span><br><span class="line">frame</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Ohio</th><br>      <th>Texas</th><br>      <th>California</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame2 = frame.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])  <span class="comment">#只重建行</span></span><br><span class="line">frame2</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Ohio</th><br>      <th>Texas</th><br>      <th>California</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div><p>指定columns关键字，可调整列索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">states = [<span class="string">'Texas'</span>, <span class="string">'Utah'</span>, <span class="string">'California'</span>]</span><br><span class="line">frame.reindex(columns=states)</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Texas</th><br>      <th>Utah</th><br>      <th>California</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1</td><br>      <td>NaN</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>4</td><br>      <td>NaN</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>7</td><br>      <td>NaN</td><br>      <td>8</td><br>    </tr><br>  </tbody><br></table><br></div><p>同时调整行和列，使用loc方法会使语义更加明确。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.loc[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], states]</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Texas</th><br>      <th>Utah</th><br>      <th>California</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>4.0</td><br>      <td>NaN</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>7.0</td><br>      <td>NaN</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div><h2 id="reindex函数参数选项"><a href="#reindex函数参数选项" class="headerlink" title="reindex函数参数选项"></a>reindex函数参数选项</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>index</td><td>指定一个序列作为调整后的序列。可以是Index对象或其他python类序列</td></tr><tr><td>method</td><td>间行填充方法， ‘ffill’向前填充,’bfill’向后填充.</td></tr><tr><td>fill_value</td><td>缺失值填充值</td></tr><tr><td>limit</td><td>填充时，填充间行的最大数</td></tr><tr><td>tolerance</td><td>填充时，不准确匹配时，填充间行的最大数</td></tr><tr><td>level</td><td>多重索引的层次中匹配简单索引，否则选择其子集</td></tr><tr><td>copy</td><td>是否拷贝原索引数据，如果新索引与老索引相等</td></tr></tbody></table><h1 id="二、使用drop函数从一条轴上删除元素"><a href="#二、使用drop函数从一条轴上删除元素" class="headerlink" title="二、使用drop函数从一条轴上删除元素"></a>二、使用drop函数从一条轴上删除元素</h1><h2 id="1-删除Series中的元素"><a href="#1-删除Series中的元素" class="headerlink" title="1.删除Series中的元素"></a>1.删除Series中的元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">obj = pd.Series(np.arange(<span class="number">5.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>a    0.0b    1.0c    2.0d    3.0e    4.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_obj = obj.drop(<span class="string">'c'</span>)  <span class="comment">#删掉索引为c的元素</span></span><br><span class="line">new_obj</span><br></pre></td></tr></table></figure><pre><code>a    0.0b    1.0d    3.0e    4.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>a    0.0b    1.0d    3.0e    4.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.drop([<span class="string">'d'</span>, <span class="string">'c'</span>]) <span class="comment">#删除d、c两个元素</span></span><br></pre></td></tr></table></figure><pre><code>a    0.0b    1.0e    4.0dtype: float64</code></pre><h2 id="2-指定轴删除DataFrame的行或列"><a href="#2-指定轴删除DataFrame的行或列" class="headerlink" title="2.指定轴删除DataFrame的行或列"></a>2.指定轴删除DataFrame的行或列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'Utah'</span>, <span class="string">'New York'</span>],columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line">data</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.drop([<span class="string">'Colorado'</span>, <span class="string">'Ohio'</span>]) <span class="comment">#沿0轴（行）删除，即根据行的索引删除行</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.drop(<span class="string">'two'</span>, axis=<span class="number">1</span>)  <span class="comment">#沿1轴（列）删除，跟根据列的标签删除指定列</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.drop([<span class="string">'two'</span>, <span class="string">'four'</span>], axis=<span class="string">'columns'</span>)  <span class="comment">#axis参数可以指定为columns，与指定为1作用相同。</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>three</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>10</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>14</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>a    0.0b    1.0c    2.0d    3.0e    4.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.drop(<span class="string">'c'</span>, inplace=<span class="keyword">True</span>)  <span class="comment">#就地修改原对象，使用inplace参数需小心，因为被删掉的元素都被销毁了。</span></span><br><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>a    0.0b    1.0d    3.0e    4.0dtype: float64</code></pre><h1 id="三、索引、选择、筛选"><a href="#三、索引、选择、筛选" class="headerlink" title="三、索引、选择、筛选"></a>三、索引、选择、筛选</h1><h2 id="对Series索引操作"><a href="#对Series索引操作" class="headerlink" title="对Series索引操作"></a>对Series索引操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>a    0.0b    1.0c    2.0d    3.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">'b'</span>] <span class="comment">#按照索引标签定位对象</span></span><br></pre></td></tr></table></figure><pre><code>1.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="number">1</span>] <span class="comment">#也可以按照位置进行索引</span></span><br></pre></td></tr></table></figure><pre><code>1.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">#切片</span></span><br></pre></td></tr></table></figure><pre><code>c    2.0d    3.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[[<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]] <span class="comment">#多个索引标签</span></span><br></pre></td></tr></table></figure><pre><code>b    1.0a    0.0d    3.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[[<span class="number">1</span>, <span class="number">3</span>]]  <span class="comment">#多个索引位置</span></span><br></pre></td></tr></table></figure><pre><code>b    1.0d    3.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[obj &lt; <span class="number">2</span>]  <span class="comment">#使用条件表达式</span></span><br></pre></td></tr></table></figure><pre><code>a    0.0b    1.0dtype: float64</code></pre><p><strong>Series使用索引标签切片与普通Numpy切片不同之处是Series切片时最后的元素是包含在内的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">'b'</span>:<span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><pre><code>b    1.0c    2.0dtype: float64</code></pre><p><strong>使用切片表达式对多个元素进行赋值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">'b'</span>:<span class="string">'c'</span>] = <span class="number">5</span></span><br><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>a    0.0b    5.0c    5.0d    3.0dtype: float64</code></pre><h2 id="对DataFrame的切片、索引操作生成一列或多列元素。"><a href="#对DataFrame的切片、索引操作生成一列或多列元素。" class="headerlink" title="对DataFrame的切片、索引操作生成一列或多列元素。"></a>对DataFrame的切片、索引操作生成一列或多列元素。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'Utah'</span>, <span class="string">'New York'</span>],columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line">data</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div><p><strong>使用列标签进行索引，得到对应的列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'two'</span>]</span><br></pre></td></tr></table></figure><pre><code>Ohio         1Colorado     5Utah         9New York    13Name: two, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[[<span class="string">'three'</span>, <span class="string">'one'</span>]]</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>three</th><br>      <th>one</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>2</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>6</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>10</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>14</td><br>      <td>12</td><br>    </tr><br>  </tbody><br></table><br></div><p><strong>行选择</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[:<span class="number">2</span>]  <span class="comment">#行选择的简便形式</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[data[<span class="string">'three'</span>] &gt; <span class="number">5</span>]  <span class="comment">#逻辑表达式，选择行</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div><p><strong>使用布尔DataFrame进行选择，用法与Numpy的二维数组是类似的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>True</td><br>      <td>True</td><br>      <td>True</td><br>      <td>True</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>True</td><br>      <td>False</td><br>      <td>False</td><br>      <td>False</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>False</td><br>      <td>False</td><br>      <td>False</td><br>      <td>False</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>False</td><br>      <td>False</td><br>      <td>False</td><br>      <td>False</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[data &lt; <span class="number">5</span>] = <span class="number">0</span>  <span class="comment">#小于5的元素赋值为0</span></span><br><span class="line">data</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>0</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>0</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div><h2 id="使用loc或iloc进行行选择"><a href="#使用loc或iloc进行行选择" class="headerlink" title="使用loc或iloc进行行选择"></a>使用loc或iloc进行行选择</h2><p>loc是用索引标签进行行选择，iloc使用整数索引进行行选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[<span class="string">'Colorado'</span>, [<span class="string">'two'</span>, <span class="string">'three'</span>]] <span class="comment">#选择Colorado行的two和three这两列的对应元素</span></span><br></pre></td></tr></table></figure><pre><code>two      5three    6Name: Colorado, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]   <span class="comment">#选择第3行的four、one、two这三列的对应元素</span></span><br></pre></td></tr></table></figure><pre><code>four    11one      8two      9Name: Utah, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[<span class="number">2</span>] <span class="comment">#第三行</span></span><br></pre></td></tr></table></figure><pre><code>one       8two       9three    10four     11Name: Utah, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]] <span class="comment">#第2、3行的第4、1、2列的对应元素</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>four</th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Colorado</th><br>      <td>7</td><br>      <td>0</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>11</td><br>      <td>8</td><br>      <td>9</td><br>    </tr><br>  </tbody><br></table><br></div><p><strong>上面的对一个或多个标签进行的索引的方法也可应用于切片</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[:<span class="string">'Utah'</span>, <span class="string">'two'</span>] <span class="comment">#Utah行之前的行的two列元素</span></span><br></pre></td></tr></table></figure><pre><code>Ohio        0Colorado    5Utah        9Name: two, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>] <span class="comment">#先选择所有的行，前3列，再使用逻辑表达式筛选</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Colorado</th><br>      <td>0</td><br>      <td>5</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>    </tr><br>  </tbody><br></table><br></div><h3 id="DataFrame的索引类型"><a href="#DataFrame的索引类型" class="headerlink" title="DataFrame的索引类型"></a>DataFrame的索引类型</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>df[val]</td><td>选择单列或多列，特殊用法：布尔值数组，切片，布尔值DataFrame</td></tr><tr><td>df.loc[val]</td><td>根据标签选择行</td></tr><tr><td>df.loc[:, val]</td><td>根据标签选择列</td></tr><tr><td>df.loc[val1, val2]</td><td>同时选择行、列</td></tr><tr><td>df.iloc[where]</td><td>根据整数位置选择行</td></tr><tr><td>df.iloc[:, where]</td><td>根据整数位置选择列</td></tr><tr><td>df.iloc[where_i, where_j]</td><td>根据整数位置同时选择行、列</td></tr><tr><td>df.at[label_i, label_j]</td><td>根据行、列标签选择一个标量值</td></tr><tr><td>df.iat[i, j]</td><td>根据整数位置选择标量值</td></tr><tr><td>reindex</td><td>根据行、列标签选择</td></tr><tr><td>get_value, set_value</td><td>根据行列标签读取值或赋值</td></tr></tbody></table><h1 id="四、整数索引产生的问题"><a href="#四、整数索引产生的问题" class="headerlink" title="四、整数索引产生的问题"></a>四、整数索引产生的问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser = pd.Series(np.arange(<span class="number">3.</span>))  <span class="comment">#不适用索引标签，索引缺省为整数序列</span></span><br><span class="line">ser</span><br></pre></td></tr></table></figure><pre><code>0    0.01    1.02    2.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser[<span class="number">2</span>]  <span class="comment">#因为是整数标签，使用的是pandas Series中的索引对象进行索引。2是索引对象[0,1,2]中的元素，所以能正常读取。</span></span><br></pre></td></tr></table></figure><pre><code>2.0</code></pre><p><strong>没有标签的情况下，使用整数位置索引，用-1取最后一个数，产生错误。因为Ser中的索引为整数0,1,2，没有-1。在python的内建索引机制中，-1是取最后一个数，而pandas是按照其索引对象来定位的，所以python内建的索引机制与pandas的索引机制在这里产生了混淆。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser[<span class="number">-1</span>]   <span class="comment"># Series索引对象[0,1,2]中不包含-1,因此出错。</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------KeyError                                  Traceback (most recent call last)&lt;ipython-input-60-3cbe0b873a9e&gt; in &lt;module&gt;()----&gt; 1 ser[-1]D:\Anaconda3\lib\site-packages\pandas\core\series.py in __getitem__(self, key)    599         key = com._apply_if_callable(key, self)    600         try:--&gt; 601             result = self.index.get_value(self, key)    602     603             if not is_scalar(result):D:\Anaconda3\lib\site-packages\pandas\core\indexes\base.py in get_value(self, series, key)   2475         try:   2476             return self._engine.get_value(s, k,-&gt; 2477                                           tz=getattr(series.dtype, &apos;tz&apos;, None))   2478         except KeyError as e1:   2479             if len(self) &gt; 0 and self.inferred_type in [&apos;integer&apos;, &apos;boolean&apos;]:pandas\_libs\index.pyx in pandas._libs.index.IndexEngine.get_value()pandas\_libs\index.pyx in pandas._libs.index.IndexEngine.get_value()pandas\_libs\index.pyx in pandas._libs.index.IndexEngine.get_loc()pandas\_libs\hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()pandas\_libs\hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()KeyError: -1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser2 = pd.Series(np.arange(<span class="number">3.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure><p><strong>使用标签的Series，因为Series的索引对象不是整数，因此使用整数索引时不会产生混淆，只可能用python内建索引机制进行选择，选择是最后一个元素。所以，为避免索引对象的混淆，使用索引标签是推荐行为。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser2[<span class="number">-1</span>]   <span class="comment">#与ser不同，这里是python内建索引机制，因此-1是读取最后一个数</span></span><br></pre></td></tr></table></figure><pre><code>2.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser[:<span class="number">1</span>]  <span class="comment">#同样，切片操作也是面向标签的。所以，因为Ser是整数索引，没有索引标签，所以这里选择的Series的整数标签行，而不是python的内建索引机制。</span></span><br></pre></td></tr></table></figure><pre><code>0    0.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser.loc[:<span class="number">1</span>]  <span class="comment">#如果用pandas的loc函数，则选择对象的意义很明确，loc函数的结果包含最后的数的</span></span><br></pre></td></tr></table></figure><pre><code>0    0.01    1.0dtype: float64</code></pre><h1 id="五、数学运算与数据对齐"><a href="#五、数学运算与数据对齐" class="headerlink" title="五、数学运算与数据对齐"></a>五、数学运算与数据对齐</h1><p> pandas的一个重要特性是两个不同索引的对象进行数学运算会如何表现。如，这两个对象的索引不同，讲这两个对象相加，如果索引对不相同，那么结果对象的索引是参加运算的两个对象的索引的并集。如果你对数据库熟悉的话，则可以理解成索引标签的outer连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">7.3</span>, <span class="number">-2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">s1</span><br></pre></td></tr></table></figure><pre><code>a    7.3c   -2.5d    3.4e    1.5dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2 = pd.Series([<span class="number">-2.1</span>, <span class="number">3.6</span>, <span class="number">-1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>],index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>])</span><br><span class="line">s2</span><br></pre></td></tr></table></figure><pre><code>a   -2.1c    3.6e   -1.5f    4.0g    3.1dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 + s2  <span class="comment">#索引标签d只在s1中，f、g只在s2中，结果是两个合集</span></span><br></pre></td></tr></table></figure><pre><code>a    5.2c    1.1d    NaNe    0.0f    NaNg    NaNdtype: float64</code></pre><h3 id="对DataFrame来说，行和列两个方向都要对齐"><a href="#对DataFrame来说，行和列两个方向都要对齐" class="headerlink" title="对DataFrame来说，行和列两个方向都要对齐"></a>对DataFrame来说，行和列两个方向都要对齐</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=list(<span class="string">'bcd'</span>),index=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Colorado'</span>])</span><br><span class="line">df1</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">df2</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>10.0</td><br>      <td>11.0</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1 + df2   <span class="comment">#两者之和，只在索引标签和列标签并集的位置数值相加，其他位置都是NaN</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Colorado</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>NaN</td><br>      <td>6.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>9.0</td><br>      <td>NaN</td><br>      <td>12.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div><p>所以，如果两个DataFrame没有共同的索引标签或行标签，加（减）运算的结果将全为NaN。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line">df1</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>A</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>2</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'B'</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">df2</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>B</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1 - df2  <span class="comment">#两者没有共同的列，所以所有的数值都是NaN</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>A</th><br>      <th>B</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div><h2 id="以填充数值进行算数运算"><a href="#以填充数值进行算数运算" class="headerlink" title="以填充数值进行算数运算"></a>以填充数值进行算数运算</h2><p>对不同索引的对象进行算数运算，如果一个对象轴中的数据在另一个对象中找不到对应的标签，可以指定填充值进行填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),columns=list(<span class="string">'abcd'</span>))</span><br><span class="line">df1</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4.0</td><br>      <td>5.0</td><br>      <td>6.0</td><br>      <td>7.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>8.0</td><br>      <td>9.0</td><br>      <td>10.0</td><br>      <td>11.0</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)),columns=list(<span class="string">'abcde'</span>))</span><br><span class="line">df2.loc[<span class="number">1</span>, <span class="string">'b'</span>] = np.nan   <span class="comment">#df2的1行b列有一个数值缺失。</span></span><br><span class="line">df2</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>      <td>3.0</td><br>      <td>4.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>5.0</td><br>      <td>NaN</td><br>      <td>7.0</td><br>      <td>8.0</td><br>      <td>9.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>10.0</td><br>      <td>11.0</td><br>      <td>12.0</td><br>      <td>13.0</td><br>      <td>14.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>15.0</td><br>      <td>16.0</td><br>      <td>17.0</td><br>      <td>18.0</td><br>      <td>19.0</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1 + df2   <span class="comment">#缺失值的计算仍是缺失值</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.0</td><br>      <td>2.0</td><br>      <td>4.0</td><br>      <td>6.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>9.0</td><br>      <td>NaN</td><br>      <td>13.0</td><br>      <td>15.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>18.0</td><br>      <td>20.0</td><br>      <td>22.0</td><br>      <td>24.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.add(df2, fill_value=<span class="number">0</span>) <span class="comment">#对df1和df2中的缺失值指定为0，然后再计算。</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.0</td><br>      <td>2.0</td><br>      <td>4.0</td><br>      <td>6.0</td><br>      <td>4.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>9.0</td><br>      <td>5.0</td><br>      <td>13.0</td><br>      <td>15.0</td><br>      <td>9.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>18.0</td><br>      <td>20.0</td><br>      <td>22.0</td><br>      <td>24.0</td><br>      <td>14.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>15.0</td><br>      <td>16.0</td><br>      <td>17.0</td><br>      <td>18.0</td><br>      <td>19.0</td><br>    </tr><br>  </tbody><br></table><br></div><h3 id="对于Series和DataFrame的Reindex函数，也可以指定缺失填充值"><a href="#对于Series和DataFrame的Reindex函数，也可以指定缺失填充值" class="headerlink" title="对于Series和DataFrame的Reindex函数，也可以指定缺失填充值"></a>对于Series和DataFrame的Reindex函数，也可以指定缺失填充值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>) <span class="comment">#对df1使用df2的列名重新创建索引，缺失的列填充为0.</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>      <td>3.0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4.0</td><br>      <td>5.0</td><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>8.0</td><br>      <td>9.0</td><br>      <td>10.0</td><br>      <td>11.0</td><br>      <td>0</td><br>    </tr><br>  </tbody><br></table><br></div><h3 id="灵活的算数运算函数"><a href="#灵活的算数运算函数" class="headerlink" title="灵活的算数运算函数"></a>灵活的算数运算函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>add, radd</td><td>相加，radd是把对象翻为右参数，下同</td></tr><tr><td>sub, rsub</td><td>相减</td></tr><tr><td>div, rdiv</td><td>相除</td></tr><tr><td>floordiv, rfloordiv</td><td>地板除(//)</td></tr><tr><td>mul, rmul</td><td>乘法</td></tr><tr><td>pow, rpow</td><td>指数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / df1</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>inf</td><br>      <td>1.000000</td><br>      <td>0.500000</td><br>      <td>0.333333</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0.250000</td><br>      <td>0.200000</td><br>      <td>0.166667</td><br>      <td>0.142857</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.125000</td><br>      <td>0.111111</td><br>      <td>0.100000</td><br>      <td>0.090909</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.rdiv(<span class="number">1</span>)  <span class="comment">#df1.rdiv(1)与1/df1等价。</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>inf</td><br>      <td>1.000000</td><br>      <td>0.500000</td><br>      <td>0.333333</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0.250000</td><br>      <td>0.200000</td><br>      <td>0.166667</td><br>      <td>0.142857</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.125000</td><br>      <td>0.111111</td><br>      <td>0.100000</td><br>      <td>0.090909</td><br>    </tr><br>  </tbody><br></table><br></div><h2 id="DateFrame和Series之间的运算"><a href="#DateFrame和Series之间的运算" class="headerlink" title="DateFrame和Series之间的运算"></a>DateFrame和Series之间的运算</h2><p>与numpy支持不同维度的数组之间的运算类似，pandas也支持DataFrame和Series之间的运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([[  0.,   1.,   2.,   3.],       [  4.,   5.,   6.,   7.],       [  8.,   9.,  10.,  11.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>array([ 0.,  1.,  2.,  3.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr - arr[<span class="number">0</span>]  <span class="comment">#DataFrame与其第一行的差</span></span><br></pre></td></tr></table></figure><pre><code>array([[ 0.,  0.,  0.,  0.],       [ 4.,  4.,  4.,  4.],       [ 8.,  8.,  8.,  8.]])</code></pre><p>上例中，Numpy数组的每一行都会减去第一行，而不是只是第一行参加运算。这就是<strong>广播（broadcasting）</strong>。在pandas中，也有类似广播模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">frame</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>10.0</td><br>      <td>11.0</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series = frame.iloc[<span class="number">0</span>]</span><br><span class="line">series</span><br></pre></td></tr></table></figure><pre><code>b    0.0d    1.0e    2.0Name: Utah, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame - series</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>3.0</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>6.0</td><br>      <td>6.0</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>9.0</td><br>      <td>9.0</td><br>    </tr><br>  </tbody><br></table><br></div><p>缺省状况下，DataFrame与Series的差是以Series的索引去匹配DataFrame的列，逐行广播运算。<br>如果一个索引的值在DataFrame列中或Series索引之一中不存在，那么结果对象会合并DataFrame列名及Series索引名以重建为新的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series2 = pd.Series(range(<span class="number">3</span>), index=[<span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line">frame + series2</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>      <th>f</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>NaN</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>NaN</td><br>      <td>6.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>6.0</td><br>      <td>NaN</td><br>      <td>9.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>NaN</td><br>      <td>12.0</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div><p>如果想要改变上述缺省行为，想要DataFrame按列广播，在行上进行匹配，那么可以用算数函数，并指定轴参数加以改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">series3 = frame[<span class="string">'d'</span>]</span><br><span class="line">series3</span><br></pre></td></tr></table></figure><pre><code>Utah       1.0Ohio       4.0Texas      7.0Oregon    10.0Name: d, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>10.0</td><br>      <td>11.0</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.sub(series3, axis=<span class="string">'index'</span>)  <span class="comment">#指定按列进行运算并广播运算。</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>-1.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>-1.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>-1.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>-1.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>    </tr><br>  </tbody><br></table><br></div><h1 id="六、函数应用及映射"><a href="#六、函数应用及映射" class="headerlink" title="六、函数应用及映射"></a>六、函数应用及映射</h1><p>numpy通用函数同样使用于pandas。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">frame</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>-0.058971</td><br>      <td>0.962351</td><br>      <td>0.886096</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>-1.397272</td><br>      <td>-0.207003</td><br>      <td>0.198786</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>-0.293349</td><br>      <td>0.303266</td><br>      <td>-0.037189</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>-1.263869</td><br>      <td>0.745421</td><br>      <td>-1.587822</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.abs(frame) <span class="comment">#求绝对值</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.058971</td><br>      <td>0.962351</td><br>      <td>0.886096</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>1.397272</td><br>      <td>0.207003</td><br>      <td>0.198786</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>0.293349</td><br>      <td>0.303266</td><br>      <td>0.037189</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>1.263869</td><br>      <td>0.745421</td><br>      <td>1.587822</td><br>    </tr><br>  </tbody><br></table><br></div><p>另外一个常用的操作是在一维数组上应用的函数可以应用到每一行或每一列。DataFrame的apply方法的具体用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x.max() - x.min()   </span><br><span class="line">frame.apply(f)     <span class="comment">#缺省情况下，对每一列应用f函数，返回结果是以列名为索引名的Series对象。</span></span><br></pre></td></tr></table></figure><pre><code>b    1.338300d    1.169354e    2.473918dtype: float64</code></pre><p>如果指定<code>axis=column</code>参数，则可按行应用<code>f</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.apply(f, axis=<span class="string">'columns'</span>)</span><br></pre></td></tr></table></figure><pre><code>Utah      1.021322Ohio      1.596058Texas     0.596615Oregon    2.333243dtype: float64</code></pre><p>大部分普通的数组统计函数（如sum和mean）都是DataFrame函数，因此apply函数并无使用的必要。<br>传递给apply的函数并非一定要返回一个标量，它也可以返回一个Series对象，即可返回一组值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.Series([x.min(), x.max()], index=[<span class="string">'min'</span>, <span class="string">'max'</span>])</span><br><span class="line">frame.apply(f)</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>min</th><br>      <td>-1.397272</td><br>      <td>-0.207003</td><br>      <td>-1.587822</td><br>    </tr><br>    <tr><br>      <th>max</th><br>      <td>-0.058971</td><br>      <td>0.962351</td><br>      <td>0.886096</td><br>    </tr><br>  </tbody><br></table><br></div><p>元素智能（element-wise）函数也可以应用在此。比如，要对DataFrame对象的每一个元素按格式字符串格式化，可以如下例这样使用applymap函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">format = <span class="keyword">lambda</span> x: <span class="string">'%.2f'</span> % x <span class="comment">#保留两位小数的格式化字符串</span></span><br><span class="line">frame.applymap(format)</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>-0.06</td><br>      <td>0.96</td><br>      <td>0.89</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>-1.40</td><br>      <td>-0.21</td><br>      <td>0.20</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>-0.29</td><br>      <td>0.30</td><br>      <td>-0.04</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>-1.26</td><br>      <td>0.75</td><br>      <td>-1.59</td><br>    </tr><br>  </tbody><br></table><br></div><p>applymap函数名称的由来是因为Series有一个对应的map函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame[<span class="string">'e'</span>].map(format)</span><br></pre></td></tr></table></figure><pre><code>Utah       0.89Ohio       0.20Texas     -0.04Oregon    -1.59Name: e, dtype: object</code></pre><h1 id="七、排序"><a href="#七、排序" class="headerlink" title="七、排序"></a>七、排序</h1><p>按照某个标准对数据集进行排序是另一个重要的内建操作。按照行名或列名的词义进行排序使用<code>sort_index</code>函数，其返回结果为一个新的排好序的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">4</span>), index=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">obj.sort_index()</span><br></pre></td></tr></table></figure><pre><code>a    1b    2c    3d    0dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),index=[<span class="string">'three'</span>, <span class="string">'one'</span>],columns=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.sort_index()  <span class="comment">#缺省，按行排序</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>d</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.sort_index(axis=<span class="number">1</span>)  <span class="comment">#也可以使用axis=1参数按列进行排序</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>three</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>one</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>4</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>) <span class="comment">#也可以降序排序</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>d</th><br>      <th>c</th><br>      <th>b</th><br>      <th>a</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>three</th><br>      <td>0</td><br>      <td>3</td><br>      <td>2</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>one</th><br>      <td>4</td><br>      <td>7</td><br>      <td>6</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div><p>对Series对象，可以使用sort_vlues对数值进行排序，而不是按照索引的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>])</span><br><span class="line">obj.sort_values()</span><br></pre></td></tr></table></figure><pre><code>2   -33    20    41    7dtype: int64</code></pre><p>缺值的位置排到后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4</span>, np.nan, <span class="number">7</span>, np.nan, <span class="number">-3</span>, <span class="number">2</span>])</span><br><span class="line">obj.sort_values()</span><br></pre></td></tr></table></figure><pre><code>4   -3.05    2.00    4.02    7.01    NaN3    NaNdtype: float64</code></pre><p>对DataFrame按值排序，可以指定一列或多列作为排序的关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line">frame</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0</td><br>      <td>-3</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.sort_values(by=<span class="string">'b'</span>) <span class="comment">#b列作为排序关键字</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2</th><br>      <td>0</td><br>      <td>-3</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.sort_values(by=[<span class="string">'a'</span>, <span class="string">'b'</span>]) <span class="comment">#a列为主关键字，b列为次关键字</span></span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2</th><br>      <td>0</td><br>      <td>-3</td><br>    </tr><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div><h2 id="Ranking排名"><a href="#Ranking排名" class="headerlink" title="Ranking排名"></a>Ranking排名</h2><p>rank函数返回从小到大排序的下标，即给予每个数值排序后所在的位置和名次。对于平级的数，rank是通过“为各组分配一个平均排名”的方式破坏评级关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">7</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">obj.rank()</span><br></pre></td></tr></table></figure><pre><code>0    6.51    1.02    6.53    4.54    3.05    2.06    4.5dtype: float64</code></pre><p>对于平级的数，也可以不使用平均排名的办法，而是可以使用位置在前面的数的排名就靠前。<br>向下面的列子，对0和2这两个位置的数，虽然平级，但是给予位置0的数的评级为6.0，位置2的数的评级为7.0，而不是6.5，因为使用的首次相遇策略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.rank(method=<span class="string">'first'</span>)</span><br></pre></td></tr></table></figure><pre><code>0    6.01    1.02    7.03    4.04    3.05    2.06    5.0dtype: float64</code></pre><p>也可以降序排列，相同评级使用最大数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.rank(ascending=<span class="keyword">False</span>, method=<span class="string">'max'</span>)</span><br></pre></td></tr></table></figure><pre><code>0    2.01    7.02    2.03    4.04    5.05    6.06    4.0dtype: float64</code></pre><p>数值相等的元素分组的评级计算方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>‘average’</td><td>缺省：对组内元素赋值平均值</td></tr><tr><td>‘min’</td><td>对分组内元素都使用最小值</td></tr><tr><td>‘max’</td><td>对分组内元素都是用最大值</td></tr><tr><td>‘first’</td><td>使用数值在数据中出现的顺序</td></tr><tr><td>‘dense’</td><td>与’min’类似，但是组间评级依次加1</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.rank(method=<span class="string">'dense'</span>)   <span class="comment">#稠密模式，评级依次加1，中间无空值</span></span><br></pre></td></tr></table></figure><pre><code>0    5.01    1.02    5.03    4.04    3.05    2.06    4.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.rank(method=<span class="string">'min'</span>)  <span class="comment">#排名中间可能有空值，该例子没有5</span></span><br></pre></td></tr></table></figure><pre><code>0    6.01    1.02    6.03    4.04    3.05    2.06    4.0dtype: float64</code></pre><h3 id="DataFrame的数值排名可以按行或列"><a href="#DataFrame的数值排名可以按行或列" class="headerlink" title="DataFrame的数值排名可以按行或列"></a>DataFrame的数值排名可以按行或列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4.3</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],<span class="string">'c'</span>: [<span class="number">-2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">-2.5</span>]&#125;)</span><br><span class="line">frame</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>4.3</td><br>      <td>-2.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>7.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0</td><br>      <td>-3.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1</td><br>      <td>2.0</td><br>      <td>-2.5</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.rank(axis=<span class="string">'columns'</span>)</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>2.0</td><br>      <td>3.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1.0</td><br>      <td>3.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2.0</td><br>      <td>1.0</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2.0</td><br>      <td>3.0</td><br>      <td>1.0</td><br>    </tr><br>  </tbody><br></table><br></div><h1 id="八、重复标签的索引"><a href="#八、重复标签的索引" class="headerlink" title="八、重复标签的索引"></a>八、重复标签的索引</h1><p>上面的例子中，DataFrame的索引标签都是唯一的。很多pandas函数（如reindex）要求索引标签是唯一的，但这不是强制的。我们来看一个重复索引标签的Series的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">5</span>), index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">obj</span><br></pre></td></tr></table></figure><pre><code>a    0a    1b    2b    3c    4dtype: int32</code></pre><p>index对象的is_unique属性可以告诉你索引标签是否是唯一的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.index.is_unique</span><br></pre></td></tr></table></figure><pre><code>False</code></pre><p>索引标签是否唯一影响数据选取的结果。如果索引标签对应多条数据，那么选取结果为Series对象，否则为一个标量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><pre><code>a    0a    1dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><pre><code>4</code></pre><p>这样的结果会使代码变得复杂，因为根据索引标签是否唯一得到的结果可能不是一种类型。这对DataFrame也是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>-0.290790</td><br>      <td>-0.402699</td><br>      <td>1.277095</td><br>    </tr><br>    <tr><br>      <th>a</th><br>      <td>0.785005</td><br>      <td>2.835915</td><br>      <td>-0.318999</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>-0.141299</td><br>      <td>-2.397378</td><br>      <td>-0.010815</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>-1.472500</td><br>      <td>1.807394</td><br>      <td>-2.828368</td><br>    </tr><br>  </tbody><br></table><br></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure><div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>b</th><br>      <td>-0.141299</td><br>      <td>-2.397378</td><br>      <td>-0.010815</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>-1.472500</td><br>      <td>1.807394</td><br>      <td>-2.828368</td><br>    </tr><br>  </tbody><br></table><br></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、重建索引（Reindex）&quot;&gt;&lt;a href=&quot;#一、重建索引（Reindex）&quot; class=&quot;headerlink&quot; title=&quot;一、重建索引（Reindex）&quot;&gt;&lt;/a&gt;一、重建索引（Reindex）&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;obj = pd.Series([&lt;span class=&quot;number&quot;&gt;4.5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7.2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-5.3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.6&lt;/span&gt;], index=[&lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Pandas" scheme="http://www.feilishu.top/categories/IT/Language/Python/Pandas/"/>
    
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
      <category term="Pandas" scheme="http://www.feilishu.top/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>numpy学习笔记5：线性代数函数及数组对象的文件读写。</title>
    <link href="http://www.feilishu.top/2017/12/19/numpy-linagl/"/>
    <id>http://www.feilishu.top/2017/12/19/numpy-linagl/</id>
    <published>2017-12-19T11:15:55.000Z</published>
    <updated>2017-12-29T14:38:40.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组文件的读写"><a href="#数组文件的读写" class="headerlink" title="数组文件的读写"></a>数组文件的读写</h1><p>np.save和np.load函数以numpy内建二进制格式存储和读取数字对象，大部分用户会用pandas或其他工具来存取文本、表格文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'some_array'</span>, arr) <span class="comment">#数组保存到some_array.npy文件中</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.load(<span class="string">'some_array.npy'</span>) <span class="comment">#从文件中读取数组</span></span><br></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr) <span class="comment">#使用关键字参数存错多个数组，未压缩格式</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>) <span class="comment">#从npz文件中读取数组数据对象，该对象以类似字典的形式表示</span></span><br><span class="line">arch[<span class="string">'b'</span>]    <span class="comment">#lazy load数组b</span></span><br></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.savez_compressed(<span class="string">'arrays_compressed.npz'</span>, a=arr, b=arr)  <span class="comment">#以压缩格式保存数组</span></span><br></pre></td></tr></table></figure><h1 id="线性代数函数"><a href="#线性代数函数" class="headerlink" title="线性代数函数"></a>线性代数函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line">x</span><br></pre></td></tr></table></figure><pre><code>array([[ 1.,  2.,  3.],       [ 4.,  5.,  6.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = np.array([[<span class="number">6.</span>, <span class="number">23.</span>], [<span class="number">-1</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">y</span><br></pre></td></tr></table></figure><pre><code>array([[  6.,  23.],       [ -1.,   7.],       [  8.,   9.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.dot(y) <span class="comment">#矩阵点乘</span></span><br></pre></td></tr></table></figure><pre><code>array([[  28.,   64.],       [  67.,  181.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.dot(x, y) <span class="comment">#全局函数形式</span></span><br></pre></td></tr></table></figure><pre><code>array([[  28.,   64.],       [  67.,  181.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.dot(x, np.ones(<span class="number">3</span>)) <span class="comment">#二维数组点乘一维向量</span></span><br></pre></td></tr></table></figure><pre><code>array([  6.,  15.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x @ np.ones(<span class="number">3</span>) <span class="comment">#python3.5版本以上，点乘可以以@表示</span></span><br></pre></td></tr></table></figure><pre><code>array([  6.,  15.])</code></pre><h2 id="numpy-linalg是numpy线性代数库，包含了常用的线性代数函数"><a href="#numpy-linalg是numpy线性代数库，包含了常用的线性代数函数" class="headerlink" title="numpy.linalg是numpy线性代数库，包含了常用的线性代数函数"></a>numpy.linalg是numpy线性代数库，包含了常用的线性代数函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br><span class="line">X = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">mat = X.T.dot(X) <span class="comment">#X的转置点乘X</span></span><br><span class="line">inv(mat) <span class="comment">#计算mat矩阵的逆矩阵</span></span><br></pre></td></tr></table></figure><pre><code>array([[  1.31386887,  -6.35141544,   1.88626458,  -6.16060108,         -1.61105243],       [ -6.35141544,  45.53241364, -12.64585185,  40.44409478,         11.13390453],       [  1.88626458, -12.64585185,   3.93294826, -11.5040055 ,         -3.15881188],       [ -6.16060108,  40.44409478, -11.5040055 ,  37.05474997,          9.82733633],       [ -1.61105243,  11.13390453,  -3.15881188,   9.82733633,          2.91712818]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mat.dot(inv(mat))</span><br></pre></td></tr></table></figure><pre><code>array([[  1.00000000e+00,  -2.03263834e-14,  -4.44066681e-15,          6.33434894e-15,   6.35591881e-16],       [ -2.46609105e-16,   1.00000000e+00,   2.45780426e-15,          2.92475759e-15,  -4.42834742e-16],       [ -1.24211599e-15,  -4.02376796e-15,   1.00000000e+00,          5.88409131e-15,   4.85369671e-16],       [ -1.82510818e-15,   6.24289242e-16,  -3.48747349e-15,          1.00000000e+00,   2.50976255e-15],       [ -1.74634203e-15,  -5.97517012e-15,   2.95250279e-16,          6.38984296e-15,   1.00000000e+00]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q, r = qr(mat) <span class="comment">#矩阵的QR分解</span></span><br><span class="line">r</span><br></pre></td></tr></table></figure><pre><code>array([[-8.96390593,  5.04075656, -2.28672019, -5.68262082, -7.65475092],       [ 0.        , -1.73065451,  1.20032719,  1.07003633,  4.51499433],       [ 0.        ,  0.        , -3.05481272, -0.64206845, -1.15803315],       [ 0.        ,  0.        ,  0.        , -0.71357743,  2.62657632],       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.06433249]])</code></pre><blockquote><p>如果实（复）非奇异矩阵A能够化成正交（酉）矩阵Q与实（复）非奇异上三角矩阵R的乘积，即A=QR，则称其为A的QR分解。<br>QR（正交三角）分解法是目前求一般矩阵全部特征值的最有效并广泛应用的方法，一般矩阵先经过正交相似变化成为Hessenberg矩阵，然后再应用QR方法求特征值和特征向量。它是将矩阵分解成一个正规正交矩阵Q与上三角形矩阵R，所以称为QR分解法，与此正规正交矩阵的通用符号Q有关。</p></blockquote><h2 id="常用线性代数函数"><a href="#常用线性代数函数" class="headerlink" title="常用线性代数函数"></a>常用线性代数函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>diag</td><td>返回一个矩阵的对角线元素组成的数组，或者根据一个一维数组产生一个以该数组为对角线的矩阵</td></tr><tr><td>dot</td><td>矩阵点乘</td></tr><tr><td>trace</td><td>计算对角线元素的和（矩阵的迹）</td></tr><tr><td>det</td><td>计算矩阵行列式</td></tr><tr><td>eig</td><td>计算特征值和特征向量</td></tr><tr><td>inv</td><td>计算矩阵的逆矩阵</td></tr><tr><td>pinv</td><td>计算 Moore-Penrose逆矩阵</td></tr><tr><td>qr</td><td>计算QR分解</td></tr><tr><td>svd</td><td>计算SVD分解</td></tr><tr><td>solve</td><td>求方程 Ax = b 中的向量X，A是矩阵</td></tr><tr><td>lstsq</td><td>计算 Ax = b的最小二乘答案</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组文件的读写&quot;&gt;&lt;a href=&quot;#数组文件的读写&quot; class=&quot;headerlink&quot; title=&quot;数组文件的读写&quot;&gt;&lt;/a&gt;数组文件的读写&lt;/h1&gt;&lt;p&gt;np.save和np.load函数以numpy内建二进制格式存储和读取数字对象，大部分用户会用pandas或其他工具来存取文本、表格文件。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr = np.arange(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;np.save(&lt;span class=&quot;string&quot;&gt;&#39;some_array&#39;&lt;/span&gt;, arr) &lt;span class=&quot;comment&quot;&gt;#数组保存到some_array.npy文件中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/categories/IT/Language/Python/Numpy/"/>
    
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>numpy学习笔记4：数学统计方法、布尔数组、排序、集合方法。</title>
    <link href="http://www.feilishu.top/2017/12/18/numpy-math-stat/"/>
    <id>http://www.feilishu.top/2017/12/18/numpy-math-stat/</id>
    <published>2017-12-18T11:15:55.000Z</published>
    <updated>2017-12-29T14:38:28.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h1><h2 id="平均值、和"><a href="#平均值、和" class="headerlink" title="平均值、和"></a>平均值、和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([[-0.74501213,  0.08417854, -1.75874197,  1.02433555],       [ 0.69482999, -0.77008213, -0.60746266,  0.15098635],       [-0.19760563, -0.00750139,  1.61108572, -0.74922113],       [-1.10606169,  0.83800608, -0.50852532, -1.50990056],       [-1.55019076, -2.07183149, -0.30625562, -0.23447214]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.mean()  <span class="comment">#平均值</span></span><br></pre></td></tr></table></figure><pre><code>-0.38597211999176573</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.mean(arr) <span class="comment">#也可以用numpy全局函数</span></span><br></pre></td></tr></table></figure><pre><code>-0.38597211999176573</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sum()  <span class="comment">#所有元素的和</span></span><br></pre></td></tr></table></figure><pre><code>-7.7194423998353141</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.mean(axis=<span class="number">1</span>)  <span class="comment">#按轴1（即按列）计算平均值，各列相加再除以列数求平均数，得数的个数为行数</span></span><br></pre></td></tr></table></figure><pre><code>array([-0.34881   , -0.13293211,  0.16418939, -0.57162037, -1.0406875 ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sum(axis=<span class="number">0</span>) <span class="comment">#按轴0（即按行）计算平均值，各行相加再除以行数求平均数，得数的个数为列数</span></span><br></pre></td></tr></table></figure><pre><code>array([-2.90404022, -1.92723039, -1.56989985, -1.31827194])</code></pre><h2 id="累加和与积函数"><a href="#累加和与积函数" class="headerlink" title="累加和与积函数"></a>累加和与积函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.cumsum()  <span class="comment">#累加和</span></span><br></pre></td></tr></table></figure><pre><code>array([ 0,  1,  3,  6, 10, 15, 21, 28], dtype=int32)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([[0, 1, 2],       [3, 4, 5],       [6, 7, 8]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.cumsum(axis=<span class="number">0</span>) <span class="comment">#按轴0，即按行累加</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.cumprod(axis=<span class="number">1</span>) <span class="comment">#按轴1，即按列累乘</span></span><br></pre></td></tr></table></figure><pre><code>array([[  0,   0,   0],       [  3,  12,  60],       [  6,  42, 336]], dtype=int32)</code></pre><h2 id="基本数组统计方法"><a href="#基本数组统计方法" class="headerlink" title="基本数组统计方法"></a>基本数组统计方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sum</td><td>数组元素和，可选参数：轴</td></tr><tr><td>mean</td><td>算数平均值</td></tr><tr><td>std, var</td><td>标准差</td></tr><tr><td>min, max</td><td>最小和最大值</td></tr><tr><td>argmin, argmax</td><td>最小和最大元素所在的位置索引</td></tr><tr><td>cumsum</td><td>累加和</td></tr><tr><td>cumprod</td><td>累加积</td></tr></tbody></table><h1 id="布尔数组有关方法"><a href="#布尔数组有关方法" class="headerlink" title="布尔数组有关方法"></a>布尔数组有关方法</h1><p>上面的方法中，对于布尔值的数组，布尔值与1（True）和0（False）等价。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line">(arr &gt; <span class="number">0</span>).sum() <span class="comment">#这样可计算数组中大于0的元素的个数</span></span><br></pre></td></tr></table></figure><pre><code>42</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bools = np.array([<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>])</span><br><span class="line">bools.any() <span class="comment">#数组中任一元素为True，则any（）返回值为True</span></span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bools.all() <span class="comment">#数组中所有元素为True，all（）方法才能返回True，否则为False</span></span><br></pre></td></tr></table></figure><pre><code>False</code></pre><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>sort方法原地修改源数组，但全局函数np.sort()创建一个排序后的数组拷贝，而不是改变原数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([ 2.12344061,  0.1013188 ,  0.41783073,  3.31179217,  1.15477831,        2.17607684])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.sort()</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([ 0.1013188 ,  0.41783073,  1.15477831,  2.12344061,  2.17607684,        3.31179217])</code></pre><p>下面一个例子，数组可按轴排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([[-0.79889695,  1.02591275,  0.16768367],       [-0.15944299, -0.22921454, -0.37237582],       [-1.58865821, -0.93659296,  0.72416659],       [-0.48231842, -0.95794791, -0.69966767],       [ 1.4034206 ,  1.3355452 , -0.19016655]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="number">1</span>) <span class="comment">#列排序 </span></span><br><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([[-0.79889695,  0.16768367,  1.02591275],       [-0.37237582, -0.22921454, -0.15944299],       [-1.58865821, -0.93659296,  0.72416659],       [-0.95794791, -0.69966767, -0.48231842],       [-0.19016655,  1.3355452 ,  1.4034206 ]])</code></pre><p>下面一个例子说明，可以以排序方法来快速计算一个数列的分位数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">large_arr = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">large_arr.sort()</span><br><span class="line">large_arr[int(<span class="number">0.05</span> * len(large_arr))] <span class="comment"># 5%分位数</span></span><br></pre></td></tr></table></figure><pre><code>-1.6172219056866222</code></pre><h1 id="唯一及其他集合方法"><a href="#唯一及其他集合方法" class="headerlink" title="唯一及其他集合方法"></a>唯一及其他集合方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">np.unique(names) <span class="comment">#去掉重复元素，并排序</span></span><br></pre></td></tr></table></figure><pre><code>array([&apos;Bob&apos;, &apos;Joe&apos;, &apos;Will&apos;],      dtype=&apos;&lt;U4&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ints = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">np.unique(ints) <span class="comment">#去掉重复元素，并排序</span></span><br></pre></td></tr></table></figure><pre><code>array([1, 2, 3, 4])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(set(names))  <span class="comment">#对比一下，这是python的原生替代方法</span></span><br></pre></td></tr></table></figure><pre><code>[&apos;Bob&apos;, &apos;Joe&apos;, &apos;Will&apos;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]) <span class="comment">#判断values中的元素是否在[2, 3, 6]中，生成一个与values数组相对应的Bool数组</span></span><br></pre></td></tr></table></figure><pre><code>array([ True, False, False,  True,  True, False,  True], dtype=bool)</code></pre><h2 id="集合类函数简表"><a href="#集合类函数简表" class="headerlink" title="集合类函数简表"></a>集合类函数简表</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>unique(x)</td><td>计算数组x中的不重复元素，并排序</td></tr><tr><td>intersect1d(x, y)</td><td>数组x和y的交集</td></tr><tr><td>union1d(x, y)</td><td>并集</td></tr><tr><td>in1d(x, y)</td><td>计算数组x中的元素是否在数组y中，产生一个与x对应的Bool数组</td></tr><tr><td>setdiff1d(x, y)</td><td>集合x与y的差集</td></tr><tr><td>setxor1d(x, y)</td><td>集合X和Y的异或并集，即两者并集减去交集</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数学和统计方法&quot;&gt;&lt;a href=&quot;#数学和统计方法&quot; class=&quot;headerlink&quot; title=&quot;数学和统计方法&quot;&gt;&lt;/a&gt;数学和统计方法&lt;/h1&gt;&lt;h2 id=&quot;平均值、和&quot;&gt;&lt;a href=&quot;#平均值、和&quot; class=&quot;headerlink&quot; title=&quot;平均值、和&quot;&gt;&lt;/a&gt;平均值、和&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr = np.random.randn(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/categories/IT/Language/Python/Numpy/"/>
    
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>numpy学习笔记3：条件表达式（where函数）。</title>
    <link href="http://www.feilishu.top/2017/12/16/where-func/"/>
    <id>http://www.feilishu.top/2017/12/16/where-func/</id>
    <published>2017-12-16T12:15:55.000Z</published>
    <updated>2017-12-29T14:36:59.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的条件表达式：where函数"><a href="#数组的条件表达式：where函数" class="headerlink" title="数组的条件表达式：where函数"></a>数组的条件表达式：where函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line">yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line">cond = np.array([<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">False</span>])</span><br><span class="line">result = np.where(cond, xarr, yarr) <span class="comment">#where函数，按cond条件选择，对应的元素为True，则选择xarr，否则选择yarr</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result</span><br></pre></td></tr></table></figure><pre><code>array([ 1.1,  2.2,  1.3,  1.4,  2.5])</code></pre><p>where函数典型的用法是给予一个array产生另一个array，如下列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([[-2.5264061 ,  0.31600076, -0.3584314 ,  1.1104543 ],       [-0.36526226,  1.35603517, -0.17306545, -1.91238476],       [ 0.89170697, -0.23551787, -0.78883913, -0.76915407],       [-0.2233249 , -0.67969266, -0.64915308, -1.46796594]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><pre><code>array([[False,  True, False,  True],       [False,  True, False, False],       [ True, False, False, False],       [False, False, False, False]], dtype=bool)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, <span class="number">-2</span>)  <span class="comment">#以标量为基础指定需要产生的元素，并不是一定是数组</span></span><br></pre></td></tr></table></figure><pre><code>array([[-2,  2, -2,  2],       [-2,  2, -2, -2],       [ 2, -2, -2, -2],       [-2, -2, -2, -2]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, arr)  <span class="comment">#也可以同时使用标量和数组为基，产生新的数组</span></span><br></pre></td></tr></table></figure><pre><code>array([[-2.5264061 ,  2.        , -0.3584314 ,  2.        ],       [-0.36526226,  2.        , -0.17306545, -1.91238476],       [ 2.        , -0.23551787, -0.78883913, -0.76915407],       [-0.2233249 , -0.67969266, -0.64915308, -1.46796594]])</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的条件表达式：where函数&quot;&gt;&lt;a href=&quot;#数组的条件表达式：where函数&quot; class=&quot;headerlink&quot; title=&quot;数组的条件表达式：where函数&quot;&gt;&lt;/a&gt;数组的条件表达式：where函数&lt;/h1&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/categories/IT/Language/Python/Numpy/"/>
    
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>numpy学习笔记2：面向数组编程。</title>
    <link href="http://www.feilishu.top/2017/12/16/array-oriented/"/>
    <id>http://www.feilishu.top/2017/12/16/array-oriented/</id>
    <published>2017-12-16T11:15:55.000Z</published>
    <updated>2017-12-29T14:38:34.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向数组的编程"><a href="#面向数组的编程" class="headerlink" title="面向数组的编程"></a>面向数组的编程</h1><p>面向数组的编程是以向量化代替使用繁杂的Loop循环。<br>下面是一个例子，我们要对一个普通网格的数值计算$sqrt(x^2 + y^2)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">points = np.arange(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">0.01</span>) <span class="comment"># 1000个元素的从-5到5到等差数列</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>meshgrid 的使用方法：<br>meshgrid函数用两个坐标轴上的点在平面上画格。[X,Y] = meshgrid(x,y) 将向量x和y定义的区域转换成矩阵X和Y，这两个矩阵可以用来表示mesh和surf的三维空间点以及两个变量的赋值。其中矩阵X的行向量是向量x的简单复制，而矩阵Y的列向量是向量y的简单复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xs, ys = np.meshgrid(points, points)    <span class="comment">#因为参数相同，所以xs和ys也是相同的</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ys</span><br></pre></td></tr></table></figure><pre><code>array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],       ...,        [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = np.sqrt(xs ** <span class="number">2</span> + ys ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z</span><br></pre></td></tr></table></figure><pre><code>array([[ 7.07106781,  7.06400028,  7.05693985, ...,  7.04988652,         7.05693985,  7.06400028],       [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,         7.04985815,  7.05692568],       [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,         7.04278354,  7.04985815],       ...,        [ 7.04988652,  7.04279774,  7.03571603, ...,  7.0286414 ,         7.03571603,  7.04279774],       [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,         7.04278354,  7.04985815],       [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,         7.04985815,  7.05692568]])</code></pre><h2 id="可以将该矩阵视觉化"><a href="#可以将该矩阵视觉化" class="headerlink" title="可以将该矩阵视觉化"></a>可以将该矩阵视觉化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pylab  <span class="comment">#不引入这个库，单纯imshow不显示图像，不知为何</span></span><br><span class="line">plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.colorbar.Colorbar at 0x81ffbf0&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">"Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values"</span>)</span><br></pre></td></tr></table></figure><pre><code>Text(0.5,1,&apos;Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pylab.show() <span class="comment">#这样才能显示图像</span></span><br></pre></td></tr></table></figure><p><img src="http://p0dt0hezd.bkt.clouddn.com/output_10_0.png" alt="png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向数组的编程&quot;&gt;&lt;a href=&quot;#面向数组的编程&quot; class=&quot;headerlink&quot; title=&quot;面向数组的编程&quot;&gt;&lt;/a&gt;面向数组的编程&lt;/h1&gt;&lt;p&gt;面向数组的编程是以向量化代替使用繁杂的Loop循环。&lt;br&gt;下面是一个例子，我们要对一个普通网格的数值计算$sqrt(x^2 + y^2)$&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;points = np.arange(&lt;span class=&quot;number&quot;&gt;-5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# 1000个元素的从-5到5到等差数列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/categories/IT/Language/Python/Numpy/"/>
    
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>Numpy学习笔记1：通用函数。</title>
    <link href="http://www.feilishu.top/2017/12/15/numpy-ufunc/"/>
    <id>http://www.feilishu.top/2017/12/15/numpy-ufunc/</id>
    <published>2017-12-15T11:15:55.000Z</published>
    <updated>2017-12-15T14:18:51.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单因子函数"><a href="#单因子函数" class="headerlink" title="单因子函数"></a>单因子函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.arange(<span class="number">10</span>)  <span class="comment">#创建一个连续序列数组</span></span><br><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(arr)  <span class="comment">#计算每个元素的平方根</span></span><br></pre></td></tr></table></figure><pre><code>array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,        2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.exp(arr)  <span class="comment">#计算指数</span></span><br></pre></td></tr></table></figure><pre><code>array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,         2.00855369e+01,   5.45981500e+01,   1.48413159e+02,         4.03428793e+02,   1.09663316e+03,   2.98095799e+03,         8.10308393e+03])</code></pre><h1 id="双因子函数"><a href="#双因子函数" class="headerlink" title="双因子函数"></a>双因子函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">8</span>)</span><br><span class="line">y = np.random.randn(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x</span><br></pre></td></tr></table></figure><pre><code>array([ 0.01390002,  0.44440568, -0.69043928,  0.77192223,  0.54505387,        1.16004907, -0.00615129,  1.75249289])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y</span><br></pre></td></tr></table></figure><pre><code>array([-1.37632082,  2.28097943, -0.08908447, -1.79805353,  1.13887393,       -0.24691048, -0.38084412, -0.06628497])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.maximum(x, y) <span class="comment">#求最大值</span></span><br></pre></td></tr></table></figure><pre><code>array([ 0.01390002,  2.28097943, -0.08908447,  0.77192223,  1.13887393,        1.16004907, -0.00615129,  1.75249289])</code></pre><h1 id="返回值是多个值的函数"><a href="#返回值是多个值的函数" class="headerlink" title="返回值是多个值的函数"></a>返回值是多个值的函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([ 2.03591268, -3.38109174,  1.00418422, -2.20275474,  2.3263392 ,        1.72357055, -3.28077738])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remainder, whole_part = np.modf(arr) <span class="comment">#求取分数部分和整数部分</span></span><br><span class="line">remainder <span class="comment">#分数部分</span></span><br></pre></td></tr></table></figure><pre><code>array([ 0.03591268, -0.38109174,  0.00418422, -0.20275474,  0.3263392 ,        0.72357055, -0.28077738])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whole_part <span class="comment">#整数部分</span></span><br></pre></td></tr></table></figure><pre><code>array([ 2., -3.,  1., -2.,  2.,  1., -3.])</code></pre><h1 id="接受一个可选的out参数，可以就地修改原数组的值"><a href="#接受一个可选的out参数，可以就地修改原数组的值" class="headerlink" title="接受一个可选的out参数，可以就地修改原数组的值"></a>接受一个可选的out参数，可以就地修改原数组的值</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([ 2.03591268, -3.38109174,  1.00418422, -2.20275474,  2.3263392 ,        1.72357055, -3.28077738])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(arr) <span class="comment">#求arr的平方根，arr不会被修改，由于其中包含负值，因此出现警告。</span></span><br></pre></td></tr></table></figure><pre><code>d:\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: invalid value encountered in sqrt  &quot;&quot;&quot;Entry point for launching an IPython kernel.array([ 1.42685412,         nan,  1.00208993,         nan,  1.52523415,        1.31284826,         nan])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="comment">#arr仍是原值</span></span><br></pre></td></tr></table></figure><pre><code>array([ 2.03591268, -3.38109174,  1.00418422, -2.20275474,  2.3263392 ,        1.72357055, -3.28077738])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(arr, arr) <span class="comment">#将arr作为out参数，则arr被就地修改</span></span><br></pre></td></tr></table></figure><pre><code>d:\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: invalid value encountered in sqrt  &quot;&quot;&quot;Entry point for launching an IPython kernel.array([ 1.42685412,         nan,  1.00208993,         nan,  1.52523415,        1.31284826,         nan])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([ 1.42685412,         nan,  1.00208993,         nan,  1.52523415,        1.31284826,         nan])</code></pre><h1 id="单因子函数-1"><a href="#单因子函数-1" class="headerlink" title="单因子函数"></a>单因子函数</h1><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>abs, fabs</td><td>计算整数、浮点数和复数的绝对值</td></tr><tr><td>sqrt</td><td>计算平方根</td></tr><tr><td>square</td><td>计算平方</td></tr><tr><td>exp</td><td>计算以e为底的指数</td></tr><tr><td>log, log10,log2, log1p</td><td>计算自然底数、10为底数、2为底数和log(1+x)</td></tr><tr><td>sign</td><td>计算每个元素的符号: 1 (正), 0 (零), or –1 (负)</td></tr><tr><td>ceil</td><td>计算大于等于元素的最小整数</td></tr><tr><td>floor</td><td>计算小于等于元素的最大整数</td></tr><tr><td>rint</td><td>取整</td></tr><tr><td>modf</td><td>求整数部分和小数部分</td></tr><tr><td>isnan</td><td>返回一个数组，其元素是标志参数元素是否是NaN的布尔值</td></tr><tr><td>isfinite,isinf</td><td>返回一个数组，其元素是标志参数元素是否是无穷大或有限数值的布尔值</td></tr><tr><td>cos, cosh, sin,sinh, tan, tanh</td><td>三角函数</td></tr><tr><td>arccos, arccosh,arcsin, arcsinh,arctan, arctanh</td><td>反三角函数</td></tr><tr><td>logical_not</td><td>逻辑非（ ~arr ）</td></tr></tbody></table><h1 id="双因子函数-1"><a href="#双因子函数-1" class="headerlink" title="双因子函数"></a>双因子函数</h1><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>add，subtract，multiply，divide, floor_divide</td><td>加法，减法、乘法、除法、不带余数除法</td></tr><tr><td>power</td><td>指数</td></tr><tr><td>maximum, fmax ，minimum, fmin</td><td>最大、最小，fmax、fmin忽略 NaN值</td></tr><tr><td>mod</td><td>余数</td></tr><tr><td>copysign</td><td>拷贝第二个参数的符号给第一个参数</td></tr><tr><td>greater, greater_equal,less, less_equal,equal, not_equal</td><td>&gt;, &gt;=, &lt;, &lt;=, ==, !=</td></tr><tr><td>logical_and,logical_or, logical_xor</td><td>逻辑并、或、异或（&amp;、&#124;、^）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单因子函数&quot;&gt;&lt;a href=&quot;#单因子函数&quot; class=&quot;headerlink&quot; title=&quot;单因子函数&quot;&gt;&lt;/a&gt;单因子函数&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/categories/IT/Language/Python/Numpy/"/>
    
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
      <category term="Numpy" scheme="http://www.feilishu.top/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda入门：Navigator、Spyder和Jupyter Notebook</title>
    <link href="http://www.feilishu.top/2017/12/05/anaconda-navigator/"/>
    <id>http://www.feilishu.top/2017/12/05/anaconda-navigator/</id>
    <published>2017-12-05T11:15:55.000Z</published>
    <updated>2017-12-29T14:37:57.193Z</updated>
    
    <content type="html"><![CDATA[<p>Anaconda安装后，可以从菜单中看到它包含几个应用程序，其中Anaconda Navigator是这几个程序的导航入口。</p><h1 id="1-Anaconda-Navigator是什么？"><a href="#1-Anaconda-Navigator是什么？" class="headerlink" title="1.Anaconda Navigator是什么？"></a>1.Anaconda Navigator是什么？</h1><p>Anaconda Navigator是Anaconda发行包中包含的桌面图形界面，可以用来方便地启动应用、方便的管理conda包、环境和频道，不需要使用命令行的命令。Navigator可以从Anaconda Cloud或本地Anaconda仓库中搜索包。提供了Windwos、maxOS和Linux版本。<br><img src="http://p0dt0hezd.bkt.clouddn.com/navigator-home-1-6.png" alt="Anaconda Navigator"></p><a id="more"></a><h1 id="2-通过Navigator可以启动那些应用？"><a href="#2-通过Navigator可以启动那些应用？" class="headerlink" title="2.通过Navigator可以启动那些应用？"></a>2.通过Navigator可以启动那些应用？</h1><p>Anaconda安装后，缺省的包含下列应用：</p><ul><li>Jupyter Notebook</li><li>Orange App</li><li>QTConsole</li><li>Glueviz</li><li>Spyder</li><li>RStudio</li></ul><h1 id="3-如何使用Navigator运行代码？"><a href="#3-如何使用Navigator运行代码？" class="headerlink" title="3.如何使用Navigator运行代码？"></a>3.如何使用Navigator运行代码？</h1><p>最简单的方式就是运行Spyder. 从Navigator的Home页面，点击Spyder, 就可以启动它并写代码并运行它了。<br><img src="http://p0dt0hezd.bkt.clouddn.com/spyder.png" alt="Spyder"></p><h1 id="4-Jupyter-Notebook介绍"><a href="#4-Jupyter-Notebook介绍" class="headerlink" title="4.Jupyter Notebook介绍"></a>4.Jupyter Notebook介绍</h1><h2 id="文学编程"><a href="#文学编程" class="headerlink" title="文学编程"></a>文学编程</h2><p>在介绍 Jupyter Notebook 之前，让我们先来看一个概念：文学编程 ( Literate programming )，这是由 Donald Knuth 提出的编程方法。传统的结构化编程，人们需要按计算机的逻辑顺序来编写代码；与此相反，文学编程则可以让人们按照自己的思维逻辑来开发程序。</p><p>简单来说，文学编程的读者不是机器，而是人。 我们从写出让机器读懂的代码，过渡到向人们解说如何让机器实现我们的想法，其中除了代码，更多的是叙述性的文字、图表等内容。这么一看，这不正是数据分析人员所需要的编码风格么？不仅要当好一个程序员，还得当好一个作家。那么 Jupyter Notebook 就是不可或缺的一款集编程和写作于一体的效率工具。</p><h2 id="历史传承"><a href="#历史传承" class="headerlink" title="历史传承"></a>历史传承</h2><p>也许说到 Jupyter 你会觉得陌生，但想必你或多或少听过鼎鼎大名的 IPython。其实Jupyter 脱胎于 IPython 项目，IPython 顾名思义，是专注于 Python 的项目，但随着项目发展壮大，已经不仅仅局限于 Python 这一种编程语言了。Jupyter 的名字就很好地释义了这一发展过程，它是 <strong>Ju</strong>lia、<strong>Py</strong>thon 以及 <strong>R</strong> 语言的组合，字形相近于木星（Jupiter），而且现在支持的语言也远超这三种了。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>以下列举了 Jupyter Notebook 的众多优点：</p><ul><li>极其适合数据分析。</li></ul><p>想象一下如下混乱的场景：你在终端中运行程序，可视化结果却显示在另一个窗口中，包含函数和类的脚本存在其他文档中，更可恶的是你还需另外写一份说明文档来解释程序如何执行以及结果如何。此时 Jupyter Notebook 从天而降，将所有内容收归一处，你是不是顿觉灵台清明，思路更加清晰了呢？</p><ul><li>支持多语言。</li></ul><p>也许你习惯使用 R 语言来做数据分析，或者是想用学术界常用的 MATLAB 和 Mathematica，这些都不成问题，只要安装相对应的核（kernel）即可。</p><ul><li>分享便捷。</li></ul><p>支持以网页的形式分享，GitHub 中天然支持 Notebook 展示，也可以通过 nbviewer 分享你的文档。当然也支持导出成 HTML、Markdown 、PDF 等多种格式的文档。</p><ul><li>远程运行。</li></ul><p>在任何地点都可以通过网络链接远程服务器来实现运算，这里给出一个远程运行的例子，可以体验一下 Jupyter Notebook。</p><ul><li>交互式展现。</li></ul><p>不仅可以输出图片、视频、数学公式，甚至可以呈现一些互动的可视化内容，比如可以缩放的地图或者是可以旋转的三维模型。这就需要交互式插件（Interactive widgets）来支持，更多内容请参考<a href="http://jupyter.org/widgets.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>如果使用 Anaconda，可以在其 Navigator 图形界面中点击打开 Notebook。但是最快捷的方法还是在命令行中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure></p><p>此时你的 Web 浏览器被自动打开，显示文件目录。通过点击右上角的 new 创建新文档。<br><img src="http://p0dt0hezd.bkt.clouddn.com/Jupiter-notebook-web.png" alt="jupyter notebook"></p><p>而关闭 notebook 文档可以通过选择文件名前的复选框后，点击 Shutdown 按钮实现。如果要关闭整个服务，则在原来的终端中按 Control + C 两次。</p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>Notebook 文档是由一系列单元（Cell）构成，主要有两种形式的单元：</p><ul><li><p>代码单元：这里是你编写代码的地方，通过按 Shift + Enter 运行代码，其结果显示在本单元下方。代码单元左边有 <code>In [1]</code>: 这样的序列标记，方便人们查看代码的执行次序。</p></li><li><p>Markdown 单元：在这里对文本进行编辑，采用 markdown 的语法规范，可以设置文本格式、插入链接、图片甚至数学公式。同样使用 Shift + Enter 运行 markdown 单元来显示格式化的文本。</p></li></ul><p><img src="http://p0dt0hezd.bkt.clouddn.com/Jupiter-notebook-sample.png" alt="jupyter notebook edit"></p><p>类似于 Linux 的 Vim 编辑器，在 notebook 中也有两种模式：</p><ul><li>编辑模式：编辑文本和代码。选中单元并按 Enter 键进入编辑模式，此时单元左侧显示绿色竖线。</li><li>命令模式：用于执行键盘输入的快捷命令。通过 Esc 键进入命令模式，此时单元左侧显示蓝色竖线。</li></ul><p>如果要使用快捷键，首先按 Esc 键进入命令模式，然后按相应的键实现对文档的操作。比如切换成代码单元（Y）或 markdown 单元（M），或者在本单元的下方增加一单元（B）。查看所有快捷命令可以按H。</p><p>尽管一开始需要花费一些学习成本，但熟练使用快捷键将大大提高工作效率。试想你在键盘上十指如飞时，如果还需要通过鼠标来操作文档，是不是很影响思考速度呢？</p><h2 id="Jupyter-Notebook-进阶功能"><a href="#Jupyter-Notebook-进阶功能" class="headerlink" title="Jupyter Notebook 进阶功能"></a>Jupyter Notebook 进阶功能</h2><h4 id="数学公式编辑"><a href="#数学公式编辑" class="headerlink" title="数学公式编辑"></a>数学公式编辑</h4><p>如果你曾做过严肃的学术研究，一定对 LaTeX 并不陌生，这简直是写科研论文的必备工具，不但能实现严格的文档排版，而且能编辑复杂的数学公式。在 Jupyter Notebook 的 markdown 单元中我们也可以使用 LaTeX 的语法来插入数学公式。</p><p>在文本行中插入数学公式，使用一对 $符号，比如质能方程 <code>$E = mc^2$</code>。如果要插入一个数学区块，则使用一对美元$符号。比如下面公式表示 z=x/y：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ $ z = frac&#123;x&#125;&#123;y&#125; $ $</span><br></pre></td></tr></table></figure></p><p>如何在 notebook 中使用 LaTeX，可进一步参考 <a href="http://data-blog.udacity.com/posts/2016/10/latex-primer/" target="_blank" rel="noopener">A Primer on Using LaTeX in Jupyter Notebooks</a> 这篇文章。</p><h4 id="幻灯片制作"><a href="#幻灯片制作" class="headerlink" title="幻灯片制作"></a>幻灯片制作</h4><p>既然Jupyter Notebook 擅长展示数据分析的过程，除了通过网页形式分享外，当然也可以将其制作成幻灯片的形式。这里有一个幻灯片示例供参考，其制作风格简洁明晰。</p><p>那么如何用 Jupyter Notebook 制作幻灯片呢？首先在 notebook 的菜单栏选择 View &gt; Cell Toolbar &gt; Slideshow，这时在文档的每个单元右上角显示了 Slide Type 的选项。通过设置不同的类型，来控制幻灯片的格式。有如下5中类型：</p><ul><li>Slide：主页面，通过按左右方向键进行切换。</li><li>Sub-Slide：副页面，通过按上下方向键进行切换。</li><li>Fragment：一开始是隐藏的，按空格键或方向键后显示，实现动态效果。</li><li>Skip：在幻灯片中不显示的单元。</li><li>Notes：作为演讲者的备忘笔记，也不在幻灯片中显示。<br><img src="http://p0dt0hezd.bkt.clouddn.com/Jupiter-notebook-slider.png" alt="jupyter notebook slide"></li></ul><p>当编写好了幻灯片形式的 notebook，如何来演示呢？这时需要使用 nbconvert：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter nbconvert notebook.ipynb --to slides --post serve</span><br></pre></td></tr></table></figure></p><p>在命令行中敲入上述代码后，浏览器会自动打开相应的幻灯片。</p><h4 id="魔术关键字"><a href="#魔术关键字" class="headerlink" title="魔术关键字"></a>魔术关键字</h4><p>魔术关键字（magic keywords），正如其名，是用于控制 notebook 的特殊的命令。它们运行在代码单元中，以 % 或者 %% 开头，前者控制一行，后者控制整个单元。</p><p>比如，要得到代码运行的时间，则可以使用 %timeit；如果要在文档中显示 matplotlib 包生成的图形，则使用 % matplotlib inline；如果要做代码调试，则使用 %pdb。但注意这些命令大多是在Python kernel 中适用的，其他 kernel 大多不适用。有许许多多的魔术关键字可以使用，更详细的清单请参考 <a href="http://ipython.readthedocs.io/en/stable/interactive/magics.html" target="_blank" rel="noopener">Built-in magic commands</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Anaconda安装后，可以从菜单中看到它包含几个应用程序，其中Anaconda Navigator是这几个程序的导航入口。&lt;/p&gt;
&lt;h1 id=&quot;1-Anaconda-Navigator是什么？&quot;&gt;&lt;a href=&quot;#1-Anaconda-Navigator是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.Anaconda Navigator是什么？&quot;&gt;&lt;/a&gt;1.Anaconda Navigator是什么？&lt;/h1&gt;&lt;p&gt;Anaconda Navigator是Anaconda发行包中包含的桌面图形界面，可以用来方便地启动应用、方便的管理conda包、环境和频道，不需要使用命令行的命令。Navigator可以从Anaconda Cloud或本地Anaconda仓库中搜索包。提供了Windwos、maxOS和Linux版本。&lt;br&gt;&lt;img src=&quot;http://p0dt0hezd.bkt.clouddn.com/navigator-home-1-6.png&quot; alt=&quot;Anaconda Navigator&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Anaconda" scheme="http://www.feilishu.top/categories/IT/Language/Python/Anaconda/"/>
    
    
      <category term="Anaconda" scheme="http://www.feilishu.top/tags/Anaconda/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda入门：安装及包与环境的管理（conda命令）。</title>
    <link href="http://www.feilishu.top/2017/12/05/anaconda/"/>
    <id>http://www.feilishu.top/2017/12/05/anaconda/</id>
    <published>2017-12-05T11:15:55.000Z</published>
    <updated>2017-12-29T14:38:41.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Anaconda是什么？"><a href="#1-Anaconda是什么？" class="headerlink" title="1.Anaconda是什么？"></a>1.Anaconda是什么？</h1><p>Anaconda在英文中是“蟒蛇”，麻辣鸡（Nicki Minaj妮琪·米娜）有首歌就叫《Anaconda》<img src="http://p0dt0hezd.bkt.clouddn.com/anaconda_song.jpg" alt="anaconda">，表示像蟒蛇一样性感妖娆的身体。</p><p>这里，Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 500 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用Miniconda这个较小的发行版（仅包含conda和 Python）。</p><a id="more"></a><p>Anaconda的图标<img src="http://p0dt0hezd.bkt.clouddn.com/anaconda_log.jpg" alt="loggo">就像一个收尾互相咬住的“蟒蛇”。</p><p>你可能已经安装了 Python，那么为什么还需要 Anaconda？有以下3个原因：</p><ol><li>Anaconda 附带了一大批常用数据科学包，它附带了 conda、Python 和 150 多个科学包及其依赖项。因此你可以立即开始处理数据。</li><li>管理包。<br>Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的。<br>在数据分析中，你会用到很多第三方的包，而conda（包管理器）可以很好的帮助你在计算机上安装和管理这些包，包括安装、卸载和更新包。</li><li>管理环境。<br>比如你在A项目中用了 Python 2，而另一个项目B却要求使用Python 3，而同时安装两个Python版本可能会造成许多混乱和错误。这时候 conda就可以帮助你为不同的项目建立不同的运行环境。<br>还有很多项目使用的包版本不同，比如不同的pandas版本，不可能同时安装两个 Numpy 版本，你要做的应该是，为每个 Numpy 版本创建一个环境，然后项目的对应环境中工作。这时候conda就可以帮你做到。</li></ol><h1 id="2-安装Anaconda"><a href="#2-安装Anaconda" class="headerlink" title="2.安装Anaconda"></a>2.安装Anaconda</h1><p>Anaconda 可用于多个平台（ Windows、Mac OS X 和 Linux）。你可以在<a href="http://continuum.io/downloads" target="_blank" rel="noopener">Anaconda官网</a>上找到安装程序和安装说明。根据你的操作系统是32位还是64位选择对应的版本下载。 </p><p>实际上，你选择对应python2或python3的哪一个版本是无所谓的，它只代表安装后缺省的python版本，因为你可以创建不同版本的环境，并可随时切换。 </p><p>安装过程中，建议不选在将Anaconda目录加入到PATH环境变量中，以免与单独安装的Python路径产生冲突。执行conda命令时，可打开Anaconda Prompt，这是Anaconda自带的终端，启动时会设置必要的环境变量，令你可运行conda命令。若汝用普通的windows cmd命令，则可能会出现找不到命令的提示。 </p><p>安装Anaconda后，需更新所有包，以防因为某些包的版本比较老旧，产生版本依赖关系错误。 在终端输入更新所有包的命令：<code>conda update --all</code>，并在提示是否更新时输入<code>y(Yes)</code>让更新继续。 </p><p>conda命令从conda cloud下载更新包，由于在境外，下载速度比较慢，甚至会由于众所周知的原因，无法下载，报错：<code>CondaHTTPError: HTTP 000 CONNECTION FAILED</code>之类的网络错误，可以用下面的方法解决：<br>在终端中运行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></p><p>添加清华大学的镜像服务器。</p><p>如果用命令行添加不上，可以在用户目录找到.condarcw文件。这个配置文件在 ~/.condarc (Linux/Mac) 或 C:\Users\当前用户名.condarc (Windows)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line"> - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"> - defaults</span><br><span class="line">show_channel_urls: true</span><br></pre></td></tr></table></figure></p><p>如果使用conda安装包的时候还是很慢，那么可以考虑使用pip来安装，同样把 pip 的镜像源地址也改成国内的，豆瓣源速度比较快。修改 ~/.pip/pip.conf (Linux/Mac) 或 C:\Users\当前用户名\pip\pip.ini (Windows) 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">trusted-host =  pypi.douban.com</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br></pre></td></tr></table></figure></p><h1 id="3-管理包"><a href="#3-管理包" class="headerlink" title="3.管理包"></a>3.管理包</h1><p>安装Anaconda后，就可以用conda命令方便的管理包了。</p><h2 id="3-1-安装包"><a href="#3-1-安装包" class="headerlink" title="3.1 安装包"></a>3.1 安装包</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure></p><p>例如：安装pandas，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condda install padas</span><br></pre></td></tr></table></figure></p><p>安装多个包，如同时安装pandas、numpy包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install padas numpy</span><br></pre></td></tr></table></figure></p><p>指定包的版本号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy=1.10</span><br></pre></td></tr></table></figure></p><p>conda会自动安装依赖项，如scipy包依赖于numpy包，那么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install scipy</span><br></pre></td></tr></table></figure></p><p>会自动安装numpy包，如果还未安装的话。</p><h2 id="3-2-卸载包"><a href="#3-2-卸载包" class="headerlink" title="3.2 卸载包"></a>3.2 卸载包</h2><p>命令：<code>conda remove package_name</code><br>例如，卸载padas包：<br><code>conda remove padas</code>  </p><h2 id="3-3-更新包"><a href="#3-3-更新包" class="headerlink" title="3.3 更新包"></a>3.3 更新包</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure></p><p>更新所有的包，加<code>--all</code>选项：<code>conda update -all</code></p><h2 id="3-4-列出所有的包"><a href="#3-4-列出所有的包" class="headerlink" title="3.4 列出所有的包"></a>3.4 列出所有的包</h2><p>命令：<code>conda list</code>  </p><h2 id="3-5-搜索包"><a href="#3-5-搜索包" class="headerlink" title="3.5 搜索包"></a>3.5 搜索包</h2><p>命令：<code>conda search search_term</code><br>例如，想检查一下numpy包是否已经安装，可使用<code>conda search num</code>模糊查找列表中是否包含numpy包。</p><blockquote><p><strong>在conda中，anything is a package</strong>。conda本身可以看做是一个包，python环境也可以看做是一个包，anaconda也是一个包，因此除了普通的第三方包支持更新之外，这三个包也支持更新。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 更新conda本身</span><br><span class="line">conda update conda</span><br><span class="line"># 更新anaconda应用</span><br><span class="line">conda update anaconda</span><br><span class="line">#更新python，假设当前python环境版本是3.6.3，而最新版本是3.6.3，那么就会升级到3.6.3。</span><br><span class="line">conda update python</span><br></pre></td></tr></table></figure><h1 id="4-管理环境"><a href="#4-管理环境" class="headerlink" title="4.管理环境"></a>4.管理环境</h1><p>conda可以为不同的项目创建不同的环境。</p><h2 id="4-1-创建环境"><a href="#4-1-创建环境" class="headerlink" title="4.1 创建环境"></a>4.1 创建环境</h2><p>命令：<code>conda create --name env_name packages_name</code><br><code>--name</code>选项可简化为<code>-n</code>，指出要创建的环境名称，并可以在创建环境时安装包。<br>例如：<code>conda create -n py3 pandas</code>创建了名称为py3的环境，并安装pandas包。<br>创建环境的时候，可以指定python的版本：<br><code>conda create -n py3 python=3</code><br>环境py3中会安装最新版本的python3。<br><code>conda create -n py3 python=3.6</code><br>指定使用3.6版本的python。  </p><h2 id="4-2-激活环境"><a href="#4-2-激活环境" class="headerlink" title="4.2 激活环境"></a>4.2 激活环境</h2><p>windows中使用<code>activate env_name</code>命令，OS/X和linux中使用<code>source activate env_name</code>命令激活环境。<br>例如：<code>activate py3</code>进入py3环境后可使用<code>conda list</code>命令查看py3<br>环境中已经安装的包。在新的环境中，可使用<code>conda install package_name</code>命令继续安装其他需要的包。</p><h2 id="4-3-离开环境"><a href="#4-3-离开环境" class="headerlink" title="4.3 离开环境"></a>4.3 离开环境</h2><p>命令：<code>deactivate</code> （windows适用）或<code>source deactivate</code>（OS/X或Linux适用）。</p><h2 id="4-4-共享环境"><a href="#4-4-共享环境" class="headerlink" title="4.4 共享环境"></a>4.4 共享环境</h2><p>如果你想向他人共享你自己创建的环境，以供其他项目用你项目的配置，主要是保持包的版本一致。就可以使用<code>conda env export &gt; enviroment.yml</code>命令将源环境的包的配置数据保存到<code>enviroment.yml</code>文件中，其他项目就可以在目标环境中，执行命令<code>conda env update -f path/to/enviroment.yml</code>将目标环境更新为与源环境完全一样。</p><p>对于不使用conda的情况下，python的pip命令也是可以做到这一点的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; enviroment.txt #将环境配置导出到enviroment.txt文本文件中。</span><br><span class="line">pip install -r /path/to/enviroment.txt #恢复环境</span><br></pre></td></tr></table></figure></p><h2 id="4-5-列出环境"><a href="#4-5-列出环境" class="headerlink" title="4.5 列出环境"></a>4.5 列出环境</h2><p>命令：<code>conda env list</code>列出所有的环境，当前激活的环境对应的目录前会显示一个*号。</p><h2 id="4-6-删除环境"><a href="#4-6-删除环境" class="headerlink" title="4.6 删除环境"></a>4.6 删除环境</h2><p>命令：<code>conda env remove -n env_name</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Anaconda是什么？&quot;&gt;&lt;a href=&quot;#1-Anaconda是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.Anaconda是什么？&quot;&gt;&lt;/a&gt;1.Anaconda是什么？&lt;/h1&gt;&lt;p&gt;Anaconda在英文中是“蟒蛇”，麻辣鸡（Nicki Minaj妮琪·米娜）有首歌就叫《Anaconda》&lt;img src=&quot;http://p0dt0hezd.bkt.clouddn.com/anaconda_song.jpg&quot; alt=&quot;anaconda&quot;&gt;，表示像蟒蛇一样性感妖娆的身体。&lt;/p&gt;
&lt;p&gt;这里，Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 500 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用Miniconda这个较小的发行版（仅包含conda和 Python）。&lt;/p&gt;
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Language" scheme="http://www.feilishu.top/categories/IT/Language/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/categories/IT/Language/Python/"/>
    
      <category term="Anaconda" scheme="http://www.feilishu.top/categories/IT/Language/Python/Anaconda/"/>
    
    
      <category term="Anaconda" scheme="http://www.feilishu.top/tags/Anaconda/"/>
    
      <category term="Python" scheme="http://www.feilishu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>神农鞭百草</title>
    <link href="http://www.feilishu.top/2017/12/03/shennong/"/>
    <id>http://www.feilishu.top/2017/12/03/shennong/</id>
    <published>2017-12-03T11:15:55.000Z</published>
    <updated>2017-12-03T11:56:08.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>神农①以赭鞭②鞭百草，尽知其平毒③寒温之性，臭味④所主。以⑤播百谷，故天下号神农也。</p><footer><strong>干宝</strong><cite>《搜神记》</cite></footer></blockquote><p><img src="http://p0dt0hezd.bkt.clouddn.com/shennong.jpg" alt=""></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>①神农：又被成为炎帝，传说中太古时期的帝王。因为传说他教会人们务农，故被成为“神农氏”。<br>②赭（zhě）鞭：传说中神农氏用来检验百草的红色鞭子。<br>③平毒： 在这里指草药含不含毒性。平，即无毒。<br>④臭（xiù）味：气味，味道。这里指酸、咸、甘、苦、辛等五味。<br>⑤以： 根据。</p><h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>神农用他那红色的鞭子抽打各种草木，既而全面了解各种草木的无毒、有毒、寒、温等药性以及酸、咸、甘、苦、辛等五味主治的疾病，然后根据这些经验，教会人们播种庄稼，所以天下人称他为“神农”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;神农①以赭鞭②鞭百草，尽知其平毒③寒温之性，臭味④所主。以⑤播百谷，故天下号神农也。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;干宝&lt;/strong&gt;&lt;cite&gt;《搜神记》&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="传统文化" scheme="http://www.feilishu.top/categories/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/"/>
    
      <category term="民间传说" scheme="http://www.feilishu.top/categories/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4/"/>
    
      <category term="神怪故事" scheme="http://www.feilishu.top/categories/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/%E6%B0%91%E9%97%B4%E4%BC%A0%E8%AF%B4/%E7%A5%9E%E6%80%AA%E6%95%85%E4%BA%8B/"/>
    
    
      <category term="搜神记" scheme="http://www.feilishu.top/tags/%E6%90%9C%E7%A5%9E%E8%AE%B0/"/>
    
      <category term="神农" scheme="http://www.feilishu.top/tags/%E7%A5%9E%E5%86%9C/"/>
    
  </entry>
  
  <entry>
    <title>Next主题使用Mathjax引擎书写LaTex数学公式</title>
    <link href="http://www.feilishu.top/2017/12/01/use-mathjax/"/>
    <id>http://www.feilishu.top/2017/12/01/use-mathjax/</id>
    <published>2017-12-01T08:18:29.193Z</published>
    <updated>2017-12-01T09:22:20.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MathJax-支持配置"><a href="#MathJax-支持配置" class="headerlink" title="MathJax 支持配置"></a>MathJax 支持配置</h1><p>在Next主题配置文件<code>_config.yml</code>中，找到<code>mathjax</code>配置段，将<code>enable</code>开关打开，但<code>per_page</code>开关建议不要打开，每个文件都加载<code>mathjax</code>引擎影响速度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure></p><p>在需要书写数学公式的页面的<code>Fromt-Matter</code>中打开<code>mathjax</code>开关即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: Next主题使用Mathjax引擎书写LaTex数学公式</span><br><span class="line">date: :year/:month/:day</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p><h1 id="Mathjax引擎渲染数学公式举例"><a href="#Mathjax引擎渲染数学公式举例" class="headerlink" title="Mathjax引擎渲染数学公式举例:"></a>Mathjax引擎渲染数学公式举例:</h1><p><code>$$ S = \pi r^2 $$</code>  </p><p>Mathjax引擎渲染为：$$ S = \pi r^2 $$  </p><p><code>$$ f = \Sigma_1^{100} x $$</code>  </p><p>Mathjax引擎渲染为：$$ f = \Sigma_1^{100} x $$  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin &#123;pmatrix&#125;</span><br><span class="line">     1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\</span><br><span class="line">     1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\</span><br><span class="line">     \vdots  &amp; \vdots&amp; \vdots &amp; \ddots &amp; \vdots \\</span><br><span class="line">     1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n    </span><br><span class="line">\end &#123;pmatrix&#125; </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>Mathjax引擎渲染为：<br>$$<br>\begin{pmatrix}<br>     1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \<br>     1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \<br>     \vdots  &amp; \vdots&amp; \vdots &amp; \ddots &amp; \vdots \<br>     1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n<br>\end{pmatrix}<br>$$</p><p>为什么不换行？？？？？!!!!<br>好大一个大坑，原因是<strong>Markdown中<code>\</code>是转义符号，LaTex公式中的<code>\\</code>换行符，必须再重复一遍，输入<code>\\\\</code>才能得到<code>\\</code>。</strong></p><p>所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;pmatrix&#125;</span><br><span class="line">     1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\\\</span><br><span class="line">     1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\\\</span><br><span class="line">     \vdots  &amp; \vdots&amp; \vdots &amp; \ddots &amp; \vdots \\\\</span><br><span class="line">     1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n    </span><br><span class="line">\end&#123;pmatrix&#125;  </span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p><p>Mathjax引擎才能渲染为：<br>$$<br>\begin{pmatrix}<br>     1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\<br>     1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\<br>     \vdots  &amp; \vdots&amp; \vdots &amp; \ddots &amp; \vdots \\<br>     1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n<br>\end{pmatrix}<br>$$</p><p>问题解决了，感觉非常爽，是不是？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MathJax-支持配置&quot;&gt;&lt;a href=&quot;#MathJax-支持配置&quot; class=&quot;headerlink&quot; title=&quot;MathJax 支持配置&quot;&gt;&lt;/a&gt;MathJax 支持配置&lt;/h1&gt;&lt;p&gt;在Next主题配置文件&lt;code&gt;_config.yml&lt;/
      
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Blog" scheme="http://www.feilishu.top/categories/IT/Blog/"/>
    
    
      <category term="Next" scheme="http://www.feilishu.top/tags/Next/"/>
    
      <category term="Mathjax" scheme="http://www.feilishu.top/tags/Mathjax/"/>
    
      <category term="LaTex" scheme="http://www.feilishu.top/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Front-matter介绍</title>
    <link href="http://www.feilishu.top/2017/11/30/hexo-front-matter/"/>
    <id>http://www.feilishu.top/2017/11/30/hexo-front-matter/</id>
    <published>2017-11-30T13:45:25.000Z</published>
    <updated>2017-12-29T14:38:37.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</p><blockquote><p>title: Hello World<br>date: 2013/7/13 20:46:25<br>-–</p></blockquote><a id="more"></a><h3 id="预定义参数"><a href="#预定义参数" class="headerlink" title="预定义参数"></a>预定义参数</h3><p>您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td></td></tr><tr><td>title</td><td>标题</td><td></td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章网址</td></tr></tbody></table><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p><blockquote><p>categories:<br>- Diary<br>tags:<br>- PS3<br>- Games  </p></blockquote><h3 id="分类方法的分歧"><a href="#分类方法的分歧" class="headerlink" title="分类方法的分歧"></a>分类方法的分歧</h3><p>如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：</p><blockquote><p>categories:<br>- Diary<br>- Life<br>会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p></blockquote><p>JSON Front-matter<br>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 — 代换成 ;;; 即可。</p><blockquote><p>“title”: “Hello World”,<br>“date”: “2013/7/13 20:46:25”<br>;;;</p></blockquote><p>最后顺便测试一下mathjax引擎渲染数学公式:<br><code>$$ S = \pi r^2 $$</code><br>$$ S = \pi r^2 $$ </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Front-matter&quot;&gt;&lt;a href=&quot;#Front-matter&quot; class=&quot;headerlink&quot; title=&quot;Front-matter&quot;&gt;&lt;/a&gt;Front-matter&lt;/h2&gt;&lt;p&gt;Front-matter是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;title: Hello World&lt;br&gt;date: 2013/7/13 20:46:25&lt;br&gt;-–&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IT" scheme="http://www.feilishu.top/categories/IT/"/>
    
      <category term="Blog" scheme="http://www.feilishu.top/categories/IT/Blog/"/>
    
    
      <category term="Next" scheme="http://www.feilishu.top/tags/Next/"/>
    
      <category term="Hexo" scheme="http://www.feilishu.top/tags/Hexo/"/>
    
      <category term="Github" scheme="http://www.feilishu.top/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.feilishu.top/2017/11/29/hello-world/"/>
    <id>http://www.feilishu.top/2017/11/29/hello-world/</id>
    <published>2017-11-29T13:39:50.474Z</published>
    <updated>2017-11-29T13:39:50.474Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
